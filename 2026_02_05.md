멤버 변수: 이 변수들은 특정 클래스에 소속된 멤버들이다.
필드: 클래스의 상태를 저장하는 변수

클래스 이름은 대문자로 시작, CamelCase로 사용

참조형 변수에서 아직 가리키는 대상이 없다면 null을 할당한다. null은 "없음"을 의미한다.

아무도 참조하지 않는 인스턴스가 있으면 JVM의 가비지 컬렉터가 메모리에서 해제한다.
null 이외에도, 지역변수도 범위를 벗어나면 가비지 컬렉터가 메모리에서 해제한다.
한번에 하나씩 지우는 게 아니라, 어느정도 쌓이면 한꺼번에 지운다. (정확한 시점은 알 수 없다.)

NullPointerException: 참조형 변수가 null일 때, 해당 변수의 멤버에 접근하려고 하면 발생하는 예외이다.

참조형의 초기값: null
기본형의 초기값: 0, 0.0, false, '\0'
없는 멤버변수에는 null을 할당한다. (컴파일 에러 발생)

절차 지향 프로그래밍: 프로그램의 흐름을 순차적으로 따르며 처리하는 방식
객체 지향 프로그래밍: 객체를 중심으로 프로그램을 작성하는 방식, "무엇"을 중심으로 프로그래밍 

차이: 절차지향은 데이터와 해당 데이터에 대한 처리 방식이 분리되어 있음. 객체지향은 데이터와 처리 방식이 하나의 객체 안에 함께 묶여있음.

객체 지향: 온전한 데이터를 가지고 스스로 처리할 수 있는 능력을 가진 객체들의 상호작용으로 프로그램을 구성하는 방식

객체 지향으로 프로그래밍을 하면, 두 가지 루트로 개발을 진행하게 되는데, 하나는 온전한 기능을 가진 객체를 개발하는 것이고, 다른 하나는 해당 객체를 활용하여 프로그램을 구성하는 것이다.

속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것을 캡슐화라 한다.

객체 지향 프로그래밍: 속성과 메서드를 잘 만들어서, "어떻게 온전한 객체를 만들 것인가?" 에 집중하는 프로그래밍 방식

this: 현재 인스턴스를 가리키는 키워드 -> 없다면? 매개변수가 항상 우선순위가 높다.
멤버면수명과 파라미터명이 다르다면 this를 사용하지 않아도 된다.

생성자는 메서드와 비슷하지만, 몇가지 차이가 있다
생성자의 이름은 클래스 이름과 같아야 한다.
생성자는 반환 타입이 없다.

클래스에 생성자가 하나도 없으면 컴파일러는 매개변수가 없고, 작동하는 코드가 없는 기본 생성자를 자동으로 만든다.
생성자가 하나라도 있다면 기본 생성자는 자동으로 만들어지지 않는다.

기본생성자를 자동으로 만들어주는 이유는, 생성자를 사용하지 않는 경우의 귀찮음을 덜어주기 위함이다.
모든 클래스는 생성자가 하나 이상 존재해야 한다. -> 기본생성자를 만들지 않으면, 매개변수가 있는 생성자만 만들 수 있다. -> 기본생성자를 호출하는 코드가 있다면 컴파일 에러가 발생한다. -> 따라서 기본생성자를 만들지 않으려면, 매개변수가 있는 생성자만 사용해야 한다.

생성자 오버로딩의 예시:
public class MemberConstructMain {
    static void main() {
        MemberConstruct member1 = new MemberConstruct("user1", 15, 90);
        MemberConstruct member2 = new MemberConstruct("user2", 16);

        MemberConstruct[] members = {member1, member2};

        for (MemberConstruct member : members) {
            System.out.println("이름:" + member.name + " 나이:" + member.age + " 성적:" + member.grade);
        }
    }
}

package construct;

public class MemberConstruct {
    String name;
    int age;
    int grade;

    MemberConstruct(String name, int age) {
        this.name = name;
        this.age = age;
        this.grade = 50;
    }

    MemberConstruct(String name, int age, int grade) {
        System.out.println("생성자 호출 name=" + name + ", age=" + age + ", grade=" + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}

생성자는 반환 타입이 없다. -> 반환 타입이 없기 때문에, 오버로딩이 가능하다.
