자바 패키지는 자바 파일을 구분하기 위한 폴더이다.
variable을 패키지를 만들었다면, 자바 파일 첫 줄에 package variable; 을 선언해야 한다.
자바 파일이 위치하는 패키지와 package varaible 선언 위치가 같아야 한다.

psvm은 main 메서드의 약자이다.
public static void main(String[] args) {
    
}

리터럴은 코드에서 "개발자가 직접 적은" 100, 100.5, 'A', "Hello", true, false와 같은 "고정된 값"을 말한다.

int a = 100 //정수 리터럴
double b = 100.5 //실수 리터럴
char c = 'A' //문자 리터럴
String d = "Hello" //문자열 리터럴
boolean e = true //불리언 리터럴

package variable;

public class Var8 {
    static void main() {
        // 정수
        byte b = 127; // 바이트
        short s = 32767; // 2바이트
        int i = 2147483647; // 4바이트
        long l; // 8바이트, 20억 넘어가는 숫자 적으면 뒤에 L을 붙임,l은 1이랑 비슷해서 권장 x

        // 실수
        float f = 10.0f; // 4바이트 7자리 정밀도, 보통 더블을 쓰고, float 쓸 거면 f를 붙여줘야 함.
        double d = 10.0; // 8바이트 15자리 정밀도

        // 기타
        boolean k = true; // 1바이트
        char c = 'd'; // 1 바이트
        String a = "hello, world!"; // 문자 하나당 1바이트 할당, 가변적.

        /*
        클래스는 대문자로 시작, 나머지는 소문자로 시작!
        변수명은 CamelCase 로 작성 할 것!
        상수는 모두 대문자를 사용하고, 언더바로 구분 -> USER_LIMIT
        패키지는 모두 소문자를 사용함 -> org.spring.boot
         */
    }
}

package string.ex;

public class OperationEx1 {
    static void main() {
        int num1 = 10, num2 = 20, num3 = 30;
        int sum = num1 + num2 + num3;
        int average = sum / 3;
        System.out.println("sum: " + sum);
        System.out.println("average: " + average); // 문자열이 숫자로 자동 변환됨!

        int score = 80;
        boolean result = score >= 80 && score <= 100;
        System.out.println(result);
    }
}


작은 범위의 타입에서 큰 범위의 타입으로 자동 형변환은 가능하지만, 큰 범위의 타입에서 작은 범위의 타입으로 자동 형변환은 불가능하다. 명시적 형변환을 해야 한다.


package typeconversion.ex;

public class TypeConversionEx1 {
    static void main() {
        // 정수형 변수 선언
        byte b = 10;
        short s = 20;
        int i = 30;
        long l = 40;

        // 실수형 변수 선언
        float f = 50.0f;
        double d = 60.0;

        // 자동 형변환 예제
        // byte -> short -> int -> long 순으로 자동 형변환 가능
        short s2 = b; // byte -> short
        int i2 = s;   // short -> int
        long l2 = i;  // int -> long

        // int -> double 순으로 자동 형변환 가능
        double d2 = i; // int -> double

        // 명시적 형변환 예제
        // 큰 범위 -> 작은 범위로 변환 시 명시적 형변환 필요
        byte b3 = (byte) s; // short -> byte
        short s3 = (short) i; // int -> short
        int i3 = (int) l; // long -> int

        // double -> float 순으로 명시적 형변환
        float f3 = (float) d; // double -> float

        // 출력
        System.out.println("자동 형변환 결과:");
        System.out.println("s2: " + s2);
        System.out.println("i2: " + i2);
        System.out.println("l2: " + l2);
        System.out.println("d2: " + d2);

        System.out.println("\n명시적 형변환 결과:");
        System.out.println("b3: " + b3);
        System.out.println("s3: " + s3);
        System.out.println("i3: " + i3);
        System.out.println("f3: " + f3);
    }
}

자바에서의 계산은 같은 타입의 결과를 낸다.
서로 다른 타입의 게산은 큰 타입으로 자동 형변환된다.
명시적 형변환을 사용하면 원하는 타입으로 계산 결과를 얻을 수 있다.

package typeconversion.ex;

public class TypeConversionEx2 {
    static void main() {
        // 정수형 변수 선언
        byte b = 10;
        short s = 20;
        int i = 30;
        long l = 40;

        // 실수형 변수 선언
        float f = 50.0f;
        double d = 60.0;

        // 정수형 변수 간의 연산
        int intResult1 = b + s; // byte + short -> int
        int intResult2 = s + i; // short + int -> int
        long longResult1 = i + l; // int + long -> long

        // 정수형과 실수형의 연산
        double doubleResult1 = i + f; // int + float -> double
        double doubleResult2 = l + d; // long + double -> double

        // 실수형 변수 간의 연산
        double doubleResult3 = f + d; // float + double -> double

        // 출력
        System.out.println("정수형 변수 간의 연산 결과:");
        System.out.println("b + s = " + intResult1);
        System.out.println("s + i = " + intResult2);
        System.out.println("i + l = " + longResult1);

        System.out.println("\n정수형과 실수형의 연산 결과:");
        System.out.println("i + f = " + doubleResult1);
        System.out.println("l + d = " + doubleResult2);

        System.out.println("\n실수형 변수 간의 연산 결과:");
        System.out.println("f + d = " + doubleResult3);
    }
}

기본형: 사용하는 값을 직접 넣을 수 있음
참조형: 값을 넣을 수 없고, 메모리 주소를 넣어야 함

기본형: int, double, char, boolean: 변수에 사용할 값을 직접 넣을 수 있음
참조형: String, Array, Class, Interface: 변수에 사용할 값을 직접 넣을 수 없고, 메모리 주소를 넣어야 함

참조형을 쓰는 이유: 배열과 같은 변수는 크기가 가변적이기 때문에 참조형을 사용한다. 또한, 객체지향 프로그래밍을 하기 위해서 참조형을 사용한다. runtime의 시점에 크기가 변할 수 있음.

자바에서는 함수를 메서드라고 함.

자바에서는 항상 변수의 값을 복사해더 대입한다.
num1 = num2 // num2의 값을 복사하여 뺀 뒤, num1에 대입한다. (num2라는 변수 자체가 들어가는 것이 아님!)

두 개의 메서드에서 각각 동일한 변수명을 사용해 하나의 메서드가 다른 메서드를 호출할 경우에는, 파라미터가 지역변수에 해당하기 때문에, 서로 다른 변수로 취급되어 한 메서드 내에서 변경된 값이 다른 메서드의 변수에 영향을 주지 않는다.
하나의 메서드에서 변경된 값을 전달하기 위해서는 return을 사용하고, 본 메서드에 대입해야 한다.

두 메서드가 있을 때, 어규먼트와 파라미터의 자료형이 다를 경우, 컴파일 에러가 발생한다. -> 명시적 형변환을 해주어야 한다.

결국, 어규먼트를 파라미터에 전달하는 것 또한, 변수를 할당하는 것과 같다. 따라서, 형변환의 모든 패턴이 그대로 적용된다. 명시적 형 변환과 자동 형변환 모두 가능하다.


메서드 오버로딩: 같은 이름의 메서드를 여러 개 정의하는 것. 단, 파라미터의 개수나 자료형이 달라야 한다.

성공 사례
add(int a, int b)
add(int a, int b, int c)
add(double a, double b)

실패 사례
int add(int a, int b)
double add(int a, int b)

메서드 시그니처 = 메서드 이름 + 파라미터의 개수와 자료형과 순서
자바의 메서드 오버로딩은 메서드 시그니처가 달라야 한다.

int add(int a, int b)
double add(int a, int b) // 실패 사례. 메서드 시그니처가 같기 때문. 리턴 타입은 메서드 시그니처에 포함되지 않는다.

int add(int a, int b)
int add(int c, int d) // 실패 사례. 메서드 시그니처가 같기 때문. 파라미터의 이름은 메서드 시그니처에 포함되지 않는다.
