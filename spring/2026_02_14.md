Model 객체: 값을 view(HTML)에 전달해주는 객체
모델 객체는 따로 생성할 필요 없이 인자로 선언하기만 하면 스프링이 알아서 만들어준다.
addAttribute("key", "value") 형태로 모델에 값을 저장한다.

스프링부트는 @Controller가 붙은 클래스의 메서드가 반환하는 문자열을 view(HTML)로 인식한다.

이 프로젝트 코드로 바로 설명하겠습니다.                                                                                                                                                                              
                                                                                                                                                                                                                       
  DTO 없이 Entity를 직접 쓰면 생기는 문제                                                                                                                                                                              
                                                                                                                                                                                                                       
  Article 엔티티를 보면:                                                                                                                                                                                               
                                                                                                                                                                                                                       
  public class Article {
      private Long id;       // DB 기본키
      private String title;
      private String content;
  }

  글 생성 API에서 클라이언트가 보내는 JSON은 {"title": "제목", "content": "내용"} 이것뿐입니다. id는 DB가 자동 생성하는 값이죠.

  만약 DTO 없이 Article을 직접 받으면:

  // DTO 없이 엔티티로 직접 받는 경우
  @PostMapping("/api/articles")
  public ResponseEntity<Article> addArticle(@RequestBody Article article) {
      // 문제 1: 클라이언트가 {"id": 999} 를 보내면 id를 맘대로 지정할 수 있음
      // 문제 2: 나중에 Article에 password 같은 필드가 추가되면? 그것도 노출됨
  }

  DTO는 "클라이언트에게 뭘 받고 뭘 보여줄지" 정하는 것

  이 프로젝트에서 DTO가 하는 역할을 보면:

  AddArticleRequest — 클라이언트한테 받을 것만 정의:
  public class AddArticleRequest {
      private String title;    // 이것만 받겠다
      private String content;  // 이것만 받겠다
      // id 없음 → 클라이언트가 id를 조작할 수 없음
  }

  ArticleResponse — 클라이언트에게 보여줄 것만 정의:
  public class ArticleResponse {
      private final String title;
      private final String content;
      // id 없음 → 클라이언트에게 id를 숨김
  }

  핵심은 "엔티티 보호"

  클라이언트 → [AddArticleRequest] → Controller → Service → [Article 엔티티] → DB
  DB → [Article 엔티티] → Service → Controller → [ArticleResponse] → 클라이언트

  - 들어올 때: DTO로 받아서 필요한 필드만 엔티티로 변환 (toEntity())
  - 나갈 때: 엔티티를 DTO로 변환해서 보여줄 필드만 노출

  엔티티는 DB 테이블 구조와 1:1 매핑인데, 클라이언트에게 보여주고 싶은 구조가 항상 테이블 구조와 같지는 않으니까 중간에 DTO를 두는 겁니다. 예를 들어 나중에 Article에 password나 deletedAt 같은 내부 필드가 추가돼도,
  ArticleResponse에 안 넣으면 클라이언트에겐 절대 노출되지 않습니다.

  - @RequiredArgsConstructor — final 필드를 받는 생성자를 Lombok이 자동 생성 → 빨간 밑줄 해결
  - @Controller — 이게 없으면 Spring이 이 클래스를 빈으로 등록하지 않아서 blogService 주입 자체가 안 됨