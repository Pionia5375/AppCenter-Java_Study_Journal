static이 붙은 멤버 변수는 메서드 영역에서 관리한다. (인스턴스 영역 x)

멤버 변수의 종류
1. 인스턴스 변수: 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있음. -> 인스턴스를 만들 때마다 새로 만들어짐.
2. static 변수: 클래스 변수, 정적 변수, static 변수 드응로 불림. 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있음. 자바 프로그램을 시작할 때 딱 1개가 만들어지고, 인스턴스와는 다르게 여러곳에서 공유하는 목적으로 사용됨.

각 변수에 접근할 때
인스턴스 변수는 인스턴스 명 + . + 변수명
static 변수는 클래스 명 + . + 변수명

변수와 생명주기
1. 지역 변수: 메서드나 생성자가 호출될 때 만들어지고, 메서드나 생성자가 종료되면 사라짐.
2. 인스턴스 변수: 인스턴스가 생성될 때 만들어지고, 인스턴스가 소멸되면 사라짐.
3. 클래스 변수: 자바 프로그램이 시작될 때 만들어지고, 자바 프로그램이 종료되면 사라짐. (JVM이 로딩될 때 생성, 종료될 때 사라짐.)

1 -> 2 -> 3 순서로 생명주기가 짧음.

정적 메서드는 static이 붙은 정적 메서드나 정적 변수만을 사용할 수 있다.
정적 메서드는 인스턴스 변수나, 인스턴스 메서드를 사용할 수 없다.

반대로 인스턴스 메서드는 static이 붙은 정적 메서드나 정적 변수, 인스턴스 변수, 인스턴스 메서드를 모두 사용할 수 있다.
 
정적 메서드는 클래스 자체에 접근하기 때문에, 인스턴스의 변수를 사용하려고 하면 참조 값이 제공되지 않아 접근이 불가한 반면, 
인스턴스 메서드는 인스턴스에 접근하기 때문에, static이 붙은 정적 메서드나 정적 변수, 인스턴스 변수, 인스턴스 메서드를 모두 사용할 수 있다. 

따라서, 정적 메서드는 인스턴스 변수 혹은 인스턴스 메서드를 포함하지 않는 간단한 기능을 구현할 때 주로 사용한다.

자바에서는 static final이 붙은 모든 변수를 상수라고 부른다. 


final 속성이 부여된 변수는 값을 변경하지 못한다. -> 보통 그래서 static과 함께 상수를 설정할 때 많이 사용된다. -> 그러나 final이 붙은 변수가 참조형 변수일 경우, 변수의 값, 즉 참조값을 변환할 수는 없지만, 그 참조하는 주소의 실제 value는 변경할 수 있다.
초기화 할 때만 값을 할당할 수 있으며, 그래서 보통 생성자를 통한 초기화 로직을 통해 여러번 활용할 수 있는 코드를 만든다. 클래스 내 멤버 변수로 final을 사용할 경우, 값을 할당하지 않고, 생성자를 통해 할당하는 것이 좋다.

상속 관계를 객체로 생성하면, 부모 클래스와 자식 클래스 모두에 메모리를 할당한다. 이 때 참조값을 확인해서 클래스를 찾아야 하는데, 이럴 경우, 호출하는 변수의 타입(클리스)를 기준으로 선택한다.

만약 자식 클래스를 선택해서 인스턴스르 생성했을 때, 자식 클래스에 호출하고자 하는 메서드가 없는 경우, 부모 클래스에서 탐색을 진행하여 사용하고, 없을 경우 컴파일 에러를 발생시킨다.

메서드 오버라이드를 할 때에는 부모 클래스보다 접근 제어자의 권한이 제한적이어서는 안된다. (public -> protected -> default -> private 순으로 제한이 강해짐)
부모 클래스의 메서드가 private으로 선언되어 있다면, 자식 클래스에서는 해당 메서드를 오버라이드 할 수 없다.
생성자는 오버라이딩 할 수 없다.

접근 제어자의 UML 표기법
+ : public
# : protected - 같은 패키지 안에서의 호출만을 허용하지만, 패키지가 달라도 상속 관계의 호출은 허횽한다.
~ : default
- : private

하자만, 부모 클래스에서 선언된 public 메서드가 해당 클래스의 private 메서드를 호출하고, 그 public 메서드를 자식 클래스에서 호출할 경우에는 private 메서드도 호출이 가능하다.

상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.

만약 부모 클래스에 기본생성자가 없으면, 자식 클래스에서 생성자를 호출할 때 super()를 통해 부모 클래스의 생성자를 명시적으로 호출해야 한다.

생성자의 초기화는 최상의 부모부터 아래로 내려오면서 진행된다.

물론 가장 처음에는 가장 밑단의 본인 클래스의 생성자가 호출되겠지만, 첫 줄에 포함된 super()를 통해 부모 클래스의 생성자가 호출되고, 그 부모 클래스의 생성자에서 super()를 통해 또 다른 부모 클래스의 생성자가 호출되는 식으로 진행된다.

클래스에 final을 붙이면 상속을 금지한다.
메서드에 final을 붙이면 오버라이딩을 금지한다.

다형적 참조: 부모 타입의 변수가 자식 인스턴스를 참조
예시:
Parent poly = new Child();
이 경우에는 poly라는 이름의 Child 인스턴스를 만들었는데, 자식의 인스턴스를 생성했기 때문에, 메모리상에 Child와 Parent가 모두 생성된다.

부모 타입은 자식 타입을 담을 수 있다. (자식은 부모의 성질을 물려받았기 때문)
이 때, poly라는 변수는 Parent 타입이기 때문에, Parent 클래스에 선언된 메서드만 호출할 수 있다.
하지만, 실제 인스턴스는 Child 타입이기 때문에, Child 클래스에 선언된 메서드도 호출할 수 있다.

부모의 속성으로 자식의 인스턴스를 만들었을 경우, 자식의 기능은 호출할 수 없다. 컴파일 오류가 발생한다.

자바에서 부모 타입은 자신은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있다.

다형적 참조의 한계로는, 부모 타입의 변수는 자식 클래스에 선언된 메서드를 호출할 수 없다는 것이다. 왜냐하면, 참조값을 통해 인스턴스를 찾았을 때, 해당하는 메서드가 없을 경우, 상속관계의 원칙에 따라 부모 방향으로만 올라가며 찾을 수 있지만, 자식 방향으로는 찾아 내려갈 수가 없기 때문이다.
이럴 경우, 자식 타입으로 강제 형변환을 해야 한다.

다형적 참조의 핵심.
Parent poly = new Parent()
Parent poly = new Child()
Parent poly = new GrandChild()

Child child = new Child()
Child child = new GrandChild()

GrandChild grandChild = new GrandChild()

부모는 자식을 담을 수 있지만, 자식은 부모를 담을 수 없다.

Child child = (Child) poly -> 강제 형변환을 통해 자식의 기능을 호출할 수 있다.

캐스팅을 한다고 Parent 타입의 변수가 Child 타입으로 바뀌는 것은 아니다. 여전히 Parent 타입이다.
해당 참조값을 꺼내고, 꺼낸 참조값을 Child 타입으로 강제 형변환을 하는 것이다.

일시적 다운캐스팅
(child) poly.childMethod() -> 형변환보다 .이 연산자 우선순위가 높기 때문에, 컴파일 에러가 발행한다.
((Child) poly).childMethod() -> 괄호를 통해 형변환을 먼저 진행한 후, 메서드를 호출한다.

((Child) poly).childMethod() // 다운캐스팅을 통해 부모 타입을 자식 타입으로 변환 후 기능 호출
((Child) x001).childMethod() // 참조값을 읽은 다음 자식 타입으로 다운캐스팅

캐스팅을 한다고 해서 Parent 타입의 변수가 Child 타입으로 바뀌는 것은 아니다. 여전히 Parent 타입이다.
해당 참조값을 꺼내고, 꺼낸 참조값을 Child 타입으로 강제 형변환을 하는 것이다.

부모자식 상속관계와는 상관없이 메서드의 우선권은 항상 오버라이딘 된 메서드가 가진다.