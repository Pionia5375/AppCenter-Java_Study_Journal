멤버 변수: 이 변수들은 특정 클래스에 소속된 멤버들이다.
필드: 클래스의 상태를 저장하는 변수

클래스 이름은 대문자로 시작, CamelCase로 사용

참조형 변수에서 아직 가리키는 대상이 없다면 null을 할당한다. null은 "없음"을 의미한다.

아무도 참조하지 않는 인스턴스가 있으면 JVM의 가비지 컬렉터가 메모리에서 해제한다.
null 이외에도, 지역변수도 범위를 벗어나면 가비지 컬렉터가 메모리에서 해제한다.
한번에 하나씩 지우는 게 아니라, 어느정도 쌓이면 한꺼번에 지운다. (정확한 시점은 알 수 없다.)

NullPointerException: 참조형 변수가 null일 때, 해당 변수의 멤버에 접근하려고 하면 발생하는 예외이다.

참조형의 초기값: null
기본형의 초기값: 0, 0.0, false, '\0'
없는 멤버변수에는 null을 할당한다. (컴파일 에러 발생)

절차 지향 프로그래밍: 프로그램의 흐름을 순차적으로 따르며 처리하는 방식
객체 지향 프로그래밍: 객체를 중심으로 프로그램을 작성하는 방식, "무엇"을 중심으로 프로그래밍 

차이: 절차지향은 데이터와 해당 데이터에 대한 처리 방식이 분리되어 있음. 객체지향은 데이터와 처리 방식이 하나의 객체 안에 함께 묶여있음.

객체 지향: 온전한 데이터를 가지고 스스로 처리할 수 있는 능력을 가진 객체들의 상호작용으로 프로그램을 구성하는 방식

객체 지향으로 프로그래밍을 하면, 두 가지 루트로 개발을 진행하게 되는데, 하나는 온전한 기능을 가진 객체를 개발하는 것이고, 다른 하나는 해당 객체를 활용하여 프로그램을 구성하는 것이다.

속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것을 캡슐화라 한다.

객체 지향 프로그래밍: 속성과 메서드를 잘 만들어서, "어떻게 온전한 객체를 만들 것인가?" 에 집중하는 프로그래밍 방식

this: 현재 인스턴스를 가리키는 키워드 -> 없다면? 매개변수가 항상 우선순위가 높다.
멤버면수명과 파라미터명이 다르다면 this를 사용하지 않아도 된다.

생성자는 메서드와 비슷하지만, 몇가지 차이가 있다
생성자의 이름은 클래스 이름과 같아야 한다.
생성자는 반환 타입이 없다.

클래스에 생성자가 하나도 없으면 컴파일러는 매개변수가 없고, 작동하는 코드가 없는 기본 생성자를 자동으로 만든다.
생성자가 하나라도 있다면 기본 생성자는 자동으로 만들어지지 않는다.

기본생성자를 자동으로 만들어주는 이유는, 생성자를 사용하지 않는 경우의 귀찮음을 덜어주기 위함이다.
모든 클래스는 생성자가 하나 이상 존재해야 한다. -> 기본생성자를 만들지 않으면, 매개변수가 있는 생성자만 만들 수 있다. -> 기본생성자를 호출하는 코드가 있다면 컴파일 에러가 발생한다. -> 따라서 기본생성자를 만들지 않으려면, 매개변수가 있는 생성자만 사용해야 한다.

생성자 오버로딩의 예시:
public class MemberConstructMain {
    static void main() {
        MemberConstruct member1 = new MemberConstruct("user1", 15, 90);
        MemberConstruct member2 = new MemberConstruct("user2", 16);

        MemberConstruct[] members = {member1, member2};

        for (MemberConstruct member : members) {
            System.out.println("이름:" + member.name + " 나이:" + member.age + " 성적:" + member.grade);
        }
    }
}

package construct;

public class MemberConstruct {
    String name;
    int age;
    int grade;

    MemberConstruct(String name, int age) {
        this.name = name;
        this.age = age;
        this.grade = 50;
    }

    MemberConstruct(String name, int age, int grade) {
        System.out.println("생성자 호출 name=" + name + ", age=" + age + ", grade=" + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}

생성자는 반환 타입이 없다. -> 반환 타입이 없기 때문에, 오버로딩이 가능하다.

다른 패키지에서 생성자를 사용하려면 public으로 선언한 뒤, import를 사용하거나, 풀네임 (~~.~.~~ 등)을 사용해야 한다.

같은 패키지 내 클래스는 서로 추가 구문 없이 사용할 수 있다.

import ~~.*을 하면, ~~ 패키지 내 모든 클래스를 사용할 수 있다.

동일한 이름을 가진 클래스가 서로 다른 패키지 내에 존재한다면, import를 사용하지 않고 풀네임을 사용해야 한다. (둘 중 하나만 임포트 가능)

a 패키지와, a.b 패키지, a.c 패키지는 서로 아무런 관계가 없다. 모두 서로 import해서 사용해야 한다.

접근 제어자 사용이유: 코드 조작으로 인한 오류 배제
종류: public, protected, default, private

public: 모든 접근 허용
protected: 같은 패키지, 자식 클래스만 접근 허용
default(package-private): 같은 패키지만 접근 허용
private: 자기 자신만 접근 허용

접근 제어자 예시:
package access.a;

public class PublicClass {
    public int publicField;
    protected int protectedField;
    int defaultField;
    private int privateField;

    public void publicMethod() {
        System.out.println("publicMethod");
    }

    protected void protectedMethod() {
        System.out.println("protectedMethod");
    }

    void defaultMethod() {
        System.out.println("defaultMethod");
    }

    private void privateMethod() {
        System.out.println("privateMethod");
    }
}

package access.b;

접근 제어자는 필드와 메서드, 생성자에 사용된다. 
클래스에는 public, default만 사용 가능하다. 
지역변수에는 접근 제어자를 사용할 수 없다.

public 클래스는 반드시 파일명과 이름이 같아야 한다. default 클래스는 파일명과 이름이 달라도 된다. -> default 클래스는 같은 패키지 내에서만 사용 가능하기 때문에 파일명과 이름이 달라도 된다. (다른 패키지에서 import 할 수 없기 때문에)

하나의 자바 파일에 default 클래스는 하나만 존재할 수 있다. public 클래스는 여러개 존재할 수 있다. -> public 클래스는 파일명과 이름이 같아야 하기 때문에, 파일명과 같은 이름의 public 클래스만 존재할 수 있다. (다른 패키지에서 import 할 수 없기 때문에)

자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역으로 구성된다.
메서드 영역: 클래스 파일의 클래스 정보를 저장하는 영역
스택 영역: 메서드 호출 시 메서드의 실행 정보를 저장하는 영역
힙 영역: 인스턴스가 생성되는 영역

메서드 영역: 클래스 정보, static 영역, 런타임 상수 풀 등을 관리
스택 영역: 자바 실행 시, 하나의 실행 스택이 생성. 메서드를 호출할 때마다 하나의 스택 프레임이 생성 (멀티스레드 사용 시 여러 개의 스택 영역 생성)
힙 영역: 인스턴스가 생성되는 영역. 가비지 컬랙션(vm이 더이상 사용하지 않는 인스턴스를 제거하는 과정)이 이루어지는 주요 영역
자바에서 각ㄱ가의 인스턴스는 내부에 변수에 메서드를 가지는데, 같은 클래스에서 생성된 객체라도, 인스턴스 내부의 변수 값은 서로 다를 수 있지만, 메서드는 공통된 코드를 공유함. 
인스턴스 변수에는 각각 메모리가 할단되지만, 메서드에 대한 새로운 메모리 할당은 없음.