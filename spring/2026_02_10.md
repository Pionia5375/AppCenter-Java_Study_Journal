# Spring Boot 입문 정리

---

## 1. 서버란?

요청을 받아서 응답을 돌려주는 프로그램(또는 그 프로그램이 돌아가는 컴퓨터)이다.

- 브라우저(클라이언트)가 HTTP 요청을 보내면, 서버가 처리해서 응답(HTML, JSON 등)을 돌려준다.
- 개발 중에는 내 컴퓨터가 서버 역할을 한다 → 그래서 localhost:8080으로 접속한다.
- 실제 서비스에서는 AWS 같은 외부 컴퓨터에 올려서 서버로 쓴다.

---

## 2. Tomcat과 내장 서버

### 서블릿 (Servlet)
- HTTP 요청을 받아서 처리하고 응답을 생성하는 **자바 클래스**이다.
- 자바로 웹 애플리케이션을 만들기 위한 가장 기본적인 기술이다.
- 예: 브라우저가 `/hello`를 요청하면, 해당 URL에 매핑된 서블릿이 실행되어 HTML이나 JSON을 응답으로 만든다.
- Spring MVC의 `DispatcherServlet`도 서블릿의 일종이다.

### 서블릿 스펙 (Servlet Specification)
- 자바 진영에서 정한 **웹 애플리케이션의 표준 규약**이다.
- "HTTP 요청/응답은 이런 형태로 처리해라", "필터는 이런 순서로 동작해라" 등의 규칙이 정의되어 있다.
- 서블릿, 필터, 리스너, 세션 관리 등의 인터페이스와 동작 방식을 명세한다.
- Tomcat, Jetty, Undertow 등은 모두 이 서블릿 스펙을 구현한 서버이다.

### 서블릿 컨테이너 (Servlet Container)
- 서블릿 스펙을 구현하여, 서블릿의 **생명주기(생성 → 초기화 → 실행 → 소멸)를 관리**하는 프로그램이다.
- 주요 역할:
  - HTTP 요청이 들어오면 알맞은 서블릿을 찾아서 실행한다.
  - 서블릿의 멀티스레드 처리를 관리한다. (요청마다 스레드를 할당)
  - 서블릿의 생명주기를 관리한다. (개발자가 직접 `new`로 생성하지 않음)
- **Tomcat** = 가장 널리 쓰이는 서블릿 컨테이너이다.

### WAR (Web Application Archive)
- 웹 애플리케이션을 배포하기 위한 **패키징 형식**이다.
- 서블릿 코드(.class), JSP, HTML, CSS, JS, 설정 파일(web.xml) 등을 하나의 `.war` 파일로 압축한 것이다.
- 과거 방식: WAR 파일을 만들어서 → 외부 Tomcat의 `webapps/` 폴더에 넣으면 → Tomcat이 이를 풀어서 실행했다.
- **Spring Boot는 WAR 대신 JAR를 사용한다.** Tomcat이 내장되어 있으므로 외부 서버에 배포할 필요 없이, `java -jar`로 바로 실행한다.

```
[과거] 개발자 코드 → WAR 패키징 → 외부 Tomcat에 배포 → 실행
[현재] 개발자 코드 → JAR 패키징 (내장 Tomcat 포함) → java -jar로 바로 실행
```

### Tomcat과 Spring Boot
- Tomcat = Java 웹 애플리케이션을 실행해주는 서블릿 컨테이너이다.
- 과거에는 Tomcat을 따로 설치하고, 내 코드를 WAR로 패키징해서 Tomcat에 배포해야 했다. (애플리케이션 따로, 서버 따로)
- Spring Boot는 Tomcat을 라이브러리로 프로젝트 안에 내장시켰다. 그래서 `./gradlew bootRun` 한 줄이면 서버가 뜬다.
- Tomcat 외에도 Jetty, Undertow 등 다른 내장 서버로 교체할 수 있다.

---

## 3. 빌드와 실행

- `gradle build`로 빌드하면 `build/libs` 폴더에 SNAPSHOT.jar 파일이 생성된다.
- `gradle clean build`로 빌드하면 기존의 build 폴더가 삭제되고, 새로운 SNAPSHOT.jar 파일이 생성된다.
- 서버를 실행할 때는 `java -jar demo-0.0.1-SNAPSHOT.jar`로 실행하면 된다.
- 이 JAR 파일 안에 내장 Tomcat + 애플리케이션 코드 + 의존성이 모두 포함되어 있다. (Fat JAR / Uber JAR)
- 중복 포트는 사용이 불가하다. (이미 8080 포트를 사용 중이면 다른 포트를 지정해야 한다.)

---

## 4. Spring Boot 프로젝트 생성 - start.spring.io

- Spring Initializr라는 공식 프로젝트 생성기 웹사이트다.
- 빌드 도구(Gradle/Maven), 언어, Spring Boot 버전, 의존성을 선택하면 프로젝트 초기 구조를 zip으로 만들어준다.

---

## 5. Starter 의존성

- 관련 라이브러리들을 하나로 묶어놓은 패키지다.
- 예: `spring-boot-starter-web` → Spring MVC, 내장 Tomcat, Jackson(JSON 처리) 등을 한번에 가져온다.
  - (참고: `spring-boot-starter-webmvc`가 아니라 `spring-boot-starter-web`이 정확한 이름이다.)
- Starter가 없으면 필요한 라이브러리를 하나하나 찾아서 버전 맞춰가며 추가해야 한다.
- Spring Boot가 버전 호환성을 자동으로 관리해주므로 버전 충돌 걱정이 없다.

---

## 6. 의존성은 어디에 있나?

- 프로젝트 안에 직접 있는 게 아니다.
- `build.gradle`에 선언하면 Gradle이 Maven Central(온라인 라이브러리 저장소)에서 자동으로 다운로드한다.
- 다운로드된 파일은 `~/.gradle/caches/`에 캐시되고, IntelliJ에서는 External Libraries에서 확인할 수 있다.

---

## 7. 전체 흐름 요약

```
start.spring.io에서 프로젝트 생성
  → Starter 의존성으로 필요한 라이브러리 자동 다운로드
    → 내장 Tomcat 포함됨
      → ./gradlew bootRun 하면 내 컴퓨터에서 서버 실행
        → 브라우저에서 localhost:8080 으로 접속
```

---

## 8. 로깅 프레임워크

- 로깅 프레임워크는 메시지 중요도(레벨) 구분, 출력 위치(콘솔, 파일) 설정 등 `System.out.println`보다 훨씬 다양한 기능을 제공한다.
- 로그 레벨: `TRACE < DEBUG < INFO < WARN < ERROR` (왼쪽이 가장 상세, 오른쪽이 가장 심각)
- Spring Boot는 기본적으로 SLF4J + Logback 조합을 사용한다.
- 실제 서비스 운영 시 필수적이다. (장애 추적, 성능 모니터링 등)

---

## 9. 요청 처리 흐름과 정적 리소스

사용자가 URL을 통해 요청을 보내면:
1. 내장 Tomcat 웹서버가 요청을 수신한다.
2. **DispatcherServlet**(스프링의 프론트 컨트롤러)이 요청을 받아서 적절한 컨트롤러를 찾는다.
3. 매핑된 컨트롤러의 메서드가 존재하면 → 해당 메서드를 실행한다.
4. 매핑된 컨트롤러가 없으면 → `resources/static` 폴더에서 해당 파일을 찾아서 반환한다.

> DispatcherServlet은 스프링 MVC의 핵심으로, 모든 HTTP 요청을 가장 먼저 받아서 적절한 핸들러(컨트롤러)에게 분배하는 역할을 한다.

---

## 10. MVC 패턴과 스프링 MVC

### MVC (Model-View-Controller) 패턴이란?
- 애플리케이션을 3개의 역할로 분리하는 **소프트웨어 디자인 패턴**이다.
- 스프링에서 만든 것이 아니라, 1979년에 제안된 범용 패턴이다. (웹, 모바일, 데스크톱 등 어디든 적용 가능)
- 핵심 목적: **화면(UI)과 비즈니스 로직을 분리**하여, 서로 영향을 주지 않고 독립적으로 수정할 수 있게 한다.

### 각 역할

| 구성 요소 | 역할 | 스프링에서의 대응 |
|-----------|------|------------------|
| **Model** | 뷰에 전달할 데이터를 담는 객체 | `Model`, `ModelAndView`, DTO |
| **View** | 데이터를 사용자에게 보여주는 화면 렌더링 | Thymeleaf, JSP 등 템플릿 엔진 |
| **Controller** | 요청을 받아서 적절한 처리를 호출하고, 결과를 뷰에 전달 | `@Controller`, `@RestController` |

### MVC의 동작 흐름 (스프링 기준)
```
1. 사용자가 URL 요청
2. DispatcherServlet이 요청을 수신
3. 적절한 Controller를 찾아서 호출
4. Controller가 Service를 호출하여 비즈니스 로직 수행
5. Controller가 결과 데이터를 Model에 담음
6. View가 Model의 데이터를 사용하여 화면을 렌더링
7. 렌더링된 HTML을 사용자에게 응답
```

> **주의**: 비즈니스 로직은 Controller가 아닌 **Service 계층**에서 처리하는 것이 올바른 설계이다. Controller는 요청/응답의 흐름만 제어한다.

```
[일반적인 스프링 계층 구조]
Controller → Service → Repository → DB
   ↓
  View (화면 렌더링이 필요한 경우)
```

### MVC를 쓰지 않으면?
- 하나의 파일에 HTML 생성 코드, DB 접근 코드, 비즈니스 로직이 전부 섞인다.
- 화면을 바꾸려면 로직 코드도 함께 건드려야 하고, 로직을 바꾸면 화면이 깨질 수 있다.
- MVC로 분리하면 View 개발자와 백엔드 개발자가 독립적으로 작업할 수 있다.

---

## 11. @ResponseBody와 HttpMessageConverter

`@ResponseBody`가 붙은 컨트롤러 메서드의 동작:
- **문자열 반환** → `StringHttpMessageConverter`가 처리하여 그대로 HTTP 응답 본문으로 전송
- **객체 반환** → `MappingJackson2HttpMessageConverter`가 처리하여 JSON 형식으로 변환 후 전송

> Jackson은 자바 객체 ↔ JSON 변환을 담당하는 대표적인 라이브러리다. Spring Boot에 기본 포함되어 있다.

참고: `@RestController` = `@Controller` + `@ResponseBody` (모든 메서드에 @ResponseBody 적용)

(IntelliJ 단축키: Control + Enter → getter and setter 자동 생성)

---

## 12. IoC (Inversion of Control) - 제어의 역전

### class, object, instance의 구분

- **class**: 설계도 (ex. 가구라는 개념)
- **object**: 설계도로부터 만들 수 있는 대상 (ex. 의자라는 개념)
- **instance**: 실제로 메모리에 생성된 객체 (ex. 눈앞에 있는 특정 의자)

### IoC란?

원래는 개발자가 직접 객체를 생성하고 관리했다:
```java
MyService service = new MyService();
```

스프링에서는 **객체의 생성과 생명주기 관리의 제어권이 개발자 → 스프링 컨테이너(IoC 컨테이너)로 넘어간다.**

- 스프링 컨테이너가 `@Component`, `@Service`, `@Repository`, `@Controller` 등의 어노테이션이 붙은 클래스를 스캔하여 자동으로 인스턴스(빈, Bean)를 생성하고 관리한다.
- 이 빈들은 기본적으로 **싱글톤(Singleton)** 으로 관리된다. (애플리케이션 전체에서 하나의 인스턴스만 존재)
- 이것이 "제어의 역전"인 이유: 객체를 내가 만드는 것이 아니라, 프레임워크가 대신 만들어준다.

---

## 13. DI (Dependency Injection) - 의존성 주입

### DI란?

객체가 필요로 하는 의존 객체를 **직접 생성하지 않고**, 스프링 컨테이너가 외부에서 주입해주는 것이다.

```java
// DI 없이 (강한 결합)
public class OrderService {
    private MemberRepository repo = new MemoryMemberRepository();
}

// DI 사용 (느슨한 결합) - 스프링이 적절한 구현체를 주입해줌
public class OrderService {
    private final MemberRepository repo;

    @Autowired
    public OrderService(MemberRepository repo) {
        this.repo = repo;
    }
}
```

### DI의 3가지 방식
1. **생성자 주입** (권장): 생성자에 `@Autowired` → 불변성 보장, 테스트 용이
2. **세터 주입**: setter 메서드에 `@Autowired`
3. **필드 주입**: 필드에 직접 `@Autowired` → 간편하지만 테스트 어려움

> 스프링 빈은 기본적으로 싱글톤이므로, 여러 클래스에 같은 타입의 빈이 주입되면 동일한 인스턴스가 주입된다.

---

## 14. 필터와 인터셉터

### 필터 (Filter)
- **서블릿 스펙에 정의된** 기능으로, Tomcat(서블릿 컨테이너) 레벨에서 동작한다.
- DispatcherServlet에 도달하기 **전/후**에 요청/응답을 가로채서 처리한다.
- 주요 용도: 인코딩 변환, XSS 방어, 인증 토큰 검증 등
- `javax.servlet.Filter` 인터페이스를 구현한다.

### 인터셉터 (Interceptor)
- **스프링 MVC에서 제공하는** 기능으로, 스프링 컨테이너 레벨에서 동작한다.
- DispatcherServlet이 컨트롤러를 호출하기 **전/후**에 요청을 가로채서 처리한다.
- 주요 용도: 로그인 체크, 권한 체크, 로깅 등
- `HandlerInterceptor` 인터페이스를 구현한다.

```
[요청 처리 순서]
HTTP 요청 → Filter → DispatcherServlet → Interceptor → Controller
```

### AOP (Aspect-Oriented Programming) - 관점 지향 프로그래밍

인터셉터와 혼동하기 쉽지만, AOP는 **별도의 프로그래밍 패러다임**이다.

**AOP란?**
- 여러 클래스/메서드에 걸쳐 **공통적으로 반복되는 관심사(횡단 관심사)** 를 분리하는 기법이다.
- 핵심 비즈니스 로직에 부가 기능(로깅, 트랜잭션, 보안 등)이 섞이는 것을 방지한다.

**횡단 관심사(Cross-Cutting Concern)의 예시:**
```java
// AOP 없이: 모든 서비스 메서드마다 로깅 코드가 반복됨
public void createOrder() {
    log.info("createOrder 시작");  // 반복
    // ... 비즈니스 로직 ...
    log.info("createOrder 끝");    // 반복
}

public void cancelOrder() {
    log.info("cancelOrder 시작");  // 반복
    // ... 비즈니스 로직 ...
    log.info("cancelOrder 끝");    // 반복
}
```
```java
// AOP 사용: 로깅 로직을 한 곳에서 분리
@Aspect
@Component
public class LoggingAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        log.info(joinPoint.getSignature().getName() + " 시작");
        Object result = joinPoint.proceed();  // 원래 메서드 실행
        log.info(joinPoint.getSignature().getName() + " 끝");
        return result;
    }
}
```

**AOP 주요 용어:**
| 용어 | 의미 |
|------|------|
| Aspect | 횡단 관심사를 모듈화한 것 (위 예시의 LoggingAspect) |
| Advice | 실제 실행되는 부가 기능 코드 (`@Before`, `@After`, `@Around`) |
| JoinPoint | Advice가 적용될 수 있는 지점 (메서드 실행 시점) |
| Pointcut | 어떤 JoinPoint에 Advice를 적용할지 정하는 표현식 |

**인터셉터 vs AOP 비교:**
| | 인터셉터 | AOP |
|--|---------|-----|
| 동작 범위 | HTTP 요청 흐름에서만 | 어떤 빈의 어떤 메서드에든 적용 가능 |
| 적용 대상 | Controller 호출 전/후 | Service, Repository 등 모든 계층 |
| 대표 용도 | 로그인 체크, API 인증 | 트랜잭션(`@Transactional`), 로깅, 성능 측정 |

> 스프링의 `@Transactional`이 대표적인 AOP 활용 사례이다. 개발자가 메서드에 `@Transactional`만 붙이면, AOP가 메서드 실행 전에 트랜잭션을 시작하고, 정상 완료 시 커밋, 예외 발생 시 롤백을 자동으로 처리한다.

---

## 15. 어노테이션과 리플렉션

### 주석 vs 어노테이션
- **주석(Comment)**: `// 내용` 또는 `/* 내용 */` → 컴파일러가 완전히 무시. 사람을 위한 설명.
- **어노테이션(Annotation)**: `@Override`, `@Component` 등 → 코드에 메타데이터를 부여한다.

### 어노테이션의 유지 정책 (Retention Policy)
- `SOURCE`: 컴파일 시 사용되고 바이트코드에서 제거됨 (ex. `@Override`)
- `CLASS`: 바이트코드에 남지만 런타임에 접근 불가 (기본값)
- `RUNTIME`: 런타임에도 접근 가능 → **리플렉션으로 읽을 수 있음** (ex. `@Component`, `@Autowired`)

### 리플렉션 (Reflection)
- 런타임에 클래스의 구조(필드, 메서드, 어노테이션 등)를 조사하고 조작할 수 있는 자바의 기능이다.
- 스프링은 리플렉션을 사용하여 `@Component`가 붙은 클래스를 찾고(IoC), `@Autowired`가 붙은 곳에 빈을 주입한다(DI).

### 어노테이션 + 리플렉션 = IoC/DI의 동작 원리
1. 스프링 부팅 시 `@ComponentScan`이 지정된 패키지를 스캔한다.
2. 리플렉션으로 `@Component`(및 파생: `@Service`, `@Repository`, `@Controller`) 어노테이션이 붙은 클래스를 찾는다.
3. 해당 클래스의 인스턴스(빈)를 생성하여 스프링 컨테이너에 등록한다. (IoC)
4. `@Autowired`가 붙은 생성자/필드/메서드를 리플렉션으로 찾아서 적절한 빈을 주입한다. (DI)

---

## 16. MessageConverter

- HTTP 요청/응답의 **본문(Body)** 과 **자바 객체** 간의 변환을 담당한다.
- "자바와 다른 언어의 변환"이 아니라, HTTP 메시지 본문의 데이터 형식(JSON, XML 등)과 자바 객체 간의 변환이다.

| 변환기 | 역할 |
|--------|------|
| `StringHttpMessageConverter` | 문자열 ↔ HTTP 본문 |
| `MappingJackson2HttpMessageConverter` | 자바 객체 ↔ JSON |

---

## 17. 데이터 통신과 인코딩

### 바이트와 문자 인코딩
- 데이터 통신의 기본 단위는 바이트(byte)이다.
- 영어권에서 컴퓨터가 만들어졌고, 영어 한 문자는 7비트(ASCII)로 표현이 가능했다. 1바이트 = 8비트가 기본 단위가 되었다.

### UTF-8
- UTF-8은 **가변 길이** 인코딩이다. (고정 3바이트가 아님)
  - 영어: 1바이트
  - 한글: 3바이트
  - 한자: 3바이트
  - 일부 이모지: 4바이트
- 전 세계 문자를 하나의 인코딩으로 표현하기 위한 표준이다.
- 현재 웹의 사실상 표준 인코딩이다.

### 자바의 스트림 처리
- `InputStream` / `OutputStream`: **바이트 스트림**을 처리한다. (원시 바이트 단위 I/O)
- `InputStreamReader` / `OutputStreamWriter`: 바이트 스트림을 지정된 인코딩에 따라 **문자 스트림**으로 변환한다.
- `BufferedReader` / `BufferedWriter`: 문자 스트림에 **버퍼링**을 추가하여 I/O 성능을 향상시킨다. (한 글자씩 읽는 대신 버퍼 단위로 한꺼번에 읽어옴)

### 스프링에서의 처리
- `@RequestBody`: HTTP 요청 본문 → 자바 객체로 변환 (내부적으로 HttpMessageConverter 사용)
- `@ResponseBody`: 자바 객체 → HTTP 응답 본문으로 변환 (내부적으로 HttpMessageConverter 사용)
- 개발자가 직접 BufferedReader/Writer를 다룰 필요 없이, 어노테이션만으로 자동 변환된다.

---

## 18. JPA (Java Persistence API)

### 인터페이스와 구현체

이 개념은 JPA를 이해하는 데 핵심적이므로 먼저 정리한다.

**인터페이스 (Interface)**
- "무엇을 해야 하는지"를 정의한 **규약(계약)** 이다. 구체적인 동작 방법은 정하지 않는다.
- 예: "데이터를 저장해라", "데이터를 조회해라"는 정해져 있지만, **어떻게** 저장하고 조회할지는 정하지 않는다.

**구현체 (Implementation)**
- 인터페이스에 정의된 규약을 **실제로 동작하도록 구현한 클래스**이다.
- 하나의 인터페이스에 여러 구현체가 존재할 수 있다.

```java
// 인터페이스: "무엇을" 할지만 정의
public interface MemberRepository {
    void save(Member member);
    Member findById(Long id);
}

// 구현체 A: MySQL로 "어떻게" 할지 구현
public class MySQLMemberRepository implements MemberRepository {
    public void save(Member member) { /* MySQL에 저장하는 코드 */ }
    public Member findById(Long id) { /* MySQL에서 조회하는 코드 */ }
}

// 구현체 B: 메모리로 "어떻게" 할지 구현
public class MemoryMemberRepository implements MemberRepository {
    public void save(Member member) { /* 메모리에 저장하는 코드 */ }
    public Member findById(Long id) { /* 메모리에서 조회하는 코드 */ }
}
```

**왜 인터페이스와 구현체를 분리하나?**
- 구현체를 교체해도 이를 사용하는 코드를 변경할 필요가 없다. (느슨한 결합)
- JPA도 같은 원리: JPA(인터페이스)를 사용하면, 구현체를 Hibernate에서 EclipseLink로 바꿔도 애플리케이션 코드는 그대로이다.

### JPA, Hibernate, JDBC의 관계

```
[계층 구조]
Spring Data JPA  (편의 기능 - Repository 자동 구현)
    ↓
   JPA           (표준 인터페이스/명세 - "무엇을" 정의)
    ↓
 Hibernate       (JPA의 구현체 - "어떻게" 구현)
    ↓
   JDBC          (자바의 DB 연결 표준 API)
    ↓
  Database
```

### JDBC (Java Database Connectivity)
- 자바에서 데이터베이스에 접속하기 위한 **가장 저수준의 표준 API**이다.
- 모든 자바 DB 접근 기술(JPA, MyBatis 등)의 밑바닥에는 JDBC가 있다.
- JDBC가 하는 일:
  1. DB와의 **커넥션(연결)** 을 생성한다.
  2. **SQL 문**을 DB에 전송한다.
  3. DB로부터 **결과(ResultSet)** 를 받아온다.

```java
// JDBC를 직접 사용하는 코드 (매우 번거로움)
Connection conn = DriverManager.getConnection(url, user, password);
PreparedStatement ps = conn.prepareStatement("SELECT * FROM member WHERE id = ?");
ps.setLong(1, memberId);
ResultSet rs = ps.executeQuery();
if (rs.next()) {
    Member member = new Member();
    member.setId(rs.getLong("id"));
    member.setName(rs.getString("name"));  // 컬럼 하나하나 수동 매핑
}
rs.close();
ps.close();
conn.close();  // 리소스 정리도 직접 해야 함
```

- 위처럼 JDBC를 직접 쓰면 반복 코드가 매우 많다. → 이 문제를 해결하기 위해 JPA, MyBatis 같은 기술이 등장했다.

### JPA (Java Persistence API)
- 자바 ORM의 **표준 인터페이스(명세)** 이다. JPA 자체는 코드가 아니라 규약이다.
- "엔티티를 이렇게 정의해라", "이런 메서드로 CRUD를 해라" 등의 규칙만 정해놓은 것이다.
- JPA만으로는 아무것도 동작하지 않는다. 반드시 **구현체**가 필요하다.

### Hibernate
- JPA 표준을 **실제로 구현한 프레임워크**이다. (JPA의 구현체)
- Spring Boot에서 `spring-boot-starter-data-jpa`를 추가하면 기본적으로 Hibernate가 동작한다.
- Hibernate가 하는 일:
  - 자바 객체 ↔ DB 테이블 간의 **매핑(ORM)** 을 처리한다.
  - 개발자가 작성한 JPQL을 각 **DB에 맞는 SQL로 변환**하여 실행한다.
  - **영속성 컨텍스트**를 관리한다. (1차 캐시, 변경 감지 등)
  - 내부적으로는 **JDBC를 사용**하여 실제 DB와 통신한다.
- JPA 외의 구현체로는 EclipseLink, OpenJPA 등이 있지만, 실무에서는 Hibernate가 사실상 표준이다.

### Spring Data JPA
- JPA/Hibernate를 더 편리하게 사용할 수 있도록 스프링이 제공하는 모듈이다.
- 인터페이스만 정의하면 구현 코드를 **자동으로 생성**해준다.

```java
// 이 인터페이스만 만들면, Spring Data JPA가 구현체를 자동 생성
public interface MemberRepository extends JpaRepository<Member, Long> {
    // save(), findById(), findAll(), delete() 등이 이미 제공됨
    // 메서드 이름만으로 쿼리 자동 생성
    List<Member> findByName(String name);
}
```

### Persistence (영속성)
- 데이터가 프로그램 종료 후에도 사라지지 않고 유지되는 성질.
- 자바 객체는 JVM 메모리에만 존재하므로, 프로그램이 종료되면 사라진다.
- 영속성을 확보하려면 데이터베이스(하드디스크)에 저장해야 한다.
- JPA는 자바 객체를 데이터베이스에 영속적으로 저장하고 관리하는 방법을 제공한다.

### 인터페이스란?
- 서로 다른 두 시스템을 연결하며, 각 시스템은 정해진 규칙(계약)에 따라 통신한다.
- JPA는 자바 애플리케이션과 데이터베이스 사이의 인터페이스 역할을 한다.

---

## 19. ORM (Object-Relational Mapping)

### 모델링
- 추상적인 개념을 구체적인 구현으로 변환하는 과정.

### 기존 방식 vs ORM 방식
- **기존 방식**: 데이터베이스 테이블을 먼저 생성하고, 해당 테이블에 맞춰서 자바 클래스를 생성한다.
- **ORM 방식**: 자바 클래스를 먼저 만들면, JPA가 이를 기반으로 데이터베이스 테이블을 자동으로 생성한다.

### 기존 자바-DB 통신의 문제점 (JDBC 직접 사용)
1. 자바가 DB에 접근하면, DB가 인증을 수행하고 커넥션을 생성한다.
2. 자바가 SQL 쿼리를 직접 작성하여 전송한다.
3. DB가 ResultSet(쿼리 결과)을 반환한다.
4. 자바에서 ResultSet을 한 컬럼씩 꺼내서 자바 객체로 수동 변환한다.
5. 사용한 리소스(ResultSet, Statement, Connection)를 수동으로 닫아야 한다.
- 반복적인 보일러플레이트 코드가 많고, SQL과 자바 코드가 뒤섞여 유지보수가 어렵다.
- (JDBC 코드 예시는 위 18절 JDBC 항목 참고)

→ **JPA를 사용하면**, `repository.save(entity)` 한 줄로 저장, `repository.findById(id)` 한 줄로 조회가 가능하다. 내부적으로 Hibernate가 JDBC를 사용하여 DB와 통신하지만, 개발자는 이를 신경 쓸 필요가 없다.

### 객체-관계 불일치 문제 (Object-Relational Impedance Mismatch)
- 객체 지향 세계에서는 상속, 다형성, 참조(레퍼런스)를 사용한다.
- 관계형 DB에서는 테이블, 외래 키(FK), 조인을 사용한다.
- 이 두 세계의 패러다임이 다르기 때문에 불일치가 발생한다.

예시:
```java
// 객체 지향: Team 객체를 직접 참조
public class Member {
    private Long id;
    private String name;
    private Team team;  // 객체 참조
}
```
```sql
-- 관계형 DB: 외래 키(FK)로 연결
CREATE TABLE member (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    team_id BIGINT REFERENCES team(id)  -- FK
);
```

→ **ORM(JPA)이 이 불일치를 자동으로 매핑해준다.**
- 자바에서 `member.getTeam()` 하면 JPA가 내부적으로 FK 조인을 수행하여 Team 객체를 가져온다.
- `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany` 등의 어노테이션으로 관계를 설정한다.

---

## 20. 영속성 컨텍스트 (Persistence Context)

### 정의
- EntityManager가 관리하는 엔티티 객체의 저장소이다.
- 자바 애플리케이션과 데이터베이스 사이에서 엔티티의 생명주기를 관리하는 1차 캐시 영역이다.

### 핵심 기능

#### 1) 1차 캐시
- 영속성 컨텍스트 내부에 캐시가 존재한다.
- 같은 엔티티를 다시 조회하면 DB에 쿼리를 보내지 않고 캐시에서 반환한다.
- 같은 트랜잭션 내에서 같은 엔티티를 조회하면 항상 같은 인스턴스를 반환한다 (동일성 보장).

#### 2) 변경 감지 (Dirty Checking)
- 영속 상태의 엔티티를 수정하면, 트랜잭션 커밋 시점에 변경 사항을 자동으로 감지하여 UPDATE 쿼리를 실행한다.
- `save()`를 다시 호출하지 않아도 된다.

```java
Member member = repository.findById(1L);
member.setName("새이름");  // 변경만 하면
// 트랜잭션 커밋 시 자동으로 UPDATE 쿼리가 실행됨
```

#### 3) 쓰기 지연 (Write-Behind)
- 엔티티를 저장(`persist`)하면 즉시 DB에 쿼리를 보내지 않고, 쓰기 지연 SQL 저장소에 모아두었다가 트랜잭션 커밋 시점에 한꺼번에 실행한다.

#### 4) 지연 로딩 (Lazy Loading)
- 연관된 엔티티를 실제로 사용하는 시점에 DB에서 조회한다.
- 불필요한 조인 쿼리를 줄여 성능을 최적화한다.

### 엔티티의 생명주기
```
비영속(new)  →  영속(managed)  →  준영속(detached)
                    ↓
                삭제(removed)
```
- **비영속**: `new` 키워드로 생성만 하고 영속성 컨텍스트와 관계 없는 상태
- **영속**: 영속성 컨텍스트에 의해 관리되는 상태 (`persist()` 호출 후)
- **준영속**: 영속성 컨텍스트에서 분리된 상태 (`detach()`, `clear()`, `close()`)
- **삭제**: 삭제된 상태 (`remove()`)

---

## 21. JPA의 DB 방언 (Dialect) 지원

- JPA는 특정 데이터베이스에 종속되지 않는다.
- JPA가 생성하는 쿼리는 JPQL(Java Persistence Query Language)이라는 추상화된 쿼리 언어를 사용한다.
- Hibernate가 설정된 Dialect에 따라 JPQL을 각 DB에 맞는 네이티브 SQL로 변환한다.
  - MySQL → `MySQLDialect`
  - PostgreSQL → `PostgreSQLDialect`
  - Oracle → `OracleDialect`
  - H2 → `H2Dialect`
- 따라서 DB를 변경하더라도 Dialect 설정만 바꾸면 애플리케이션 코드를 수정할 필요가 없다. (높은 호환성)
