스프링 시큐리티: 스프링 기반이 애플리케이션 보안을 담당하는 스프링 하위 프레임워크

인증: 로그인, 회원가입 등 사용자가 누구인지 확인하는 과정
인가: 로그인한 사용자가 특정 리소스에 접근할 수 있는지 확인하는 과정

인증과 인가 관련 코드 처리를 아주 쉽게 처리해줌.

CSRF: 사용자의 권한을 가지고 특정 동작을 수행하도록 유도하는 공격
세션 고정 공격: 사용자의 인증 정보를 탈취하거나 변고하는 공격

스프링 시큐리티의 필터 구조.

아이디 패스워드 인증처리 절차
1. 사용자가 폼에 아이디와 패스워드를 입력하면, HTTPServletRequest 객체에 담겨서 서블릿으로 전달된다.
2. AuthenticationFilter가 요청의 유효성 검사를 실행 -> 검사 성공 시, UsernamePasswordAuthenticationToken 객체를 생성한 뒤, AuthenticationManager에게 전달한다.
3. AuthenticationManager가 AuthenticationProvider에게 UsernamePasswordAuthenticationToken 객체를 전달하여 인증을 요청한다.
4. AuthenticationProvider는 UserDetailsService에게 사용자 아이디를 전달하여 사용자 정보를 요청한다.
6. AuthenticationProvider는 사용자 정보를 기반으로 인증을 실행한다.
7. 인증 성공 시, SecurityContextHolder에 인증 정보를 저장하고, AuthenticationSuccessHandler를 실행한다.
8. 인증 실패 시, AuthenticationFailureHandler가 인증 실패 처리를 실행한다.

스프링 시큐리티를 사용해 인증, 인가 기능을 구현하는 절차
1. 회원 정보 테이블을 생성
2. 테이블과 연결할 도메인 생성
3. 테이블과 연결할 엔티티 생성
4. 데이터 조회용 리포지토리 생성
5. 사용자 정보조회 서비스 생성

Collection<? extends GrantedAuthority> 문법 해설                                                                                                                                                                       
                                                                                                                                                                                                                       
  하나씩 뜯어보기                                                                                                                                                                                                        
                                                                                                                                                                                                                       
  Collection<? extends GrantedAuthority>                                                                                                                                                                                 
                                                                                                                                                                                                                       
  이건 3가지 개념이 합쳐진 것입니다.

  ---
  1. Collection<T> — 제네릭 컬렉션

  Collection은 여러 객체를 담는 컨테이너입니다. <T>로 담을 타입을 지정합니다.

  Collection<String> names;       // String만 담는 컬렉션
  Collection<Integer> numbers;    // Integer만 담는 컬렉션
  Collection<GrantedAuthority> authorities;  // GrantedAuthority만 담는 컬렉션

  List, Set 모두 Collection의 하위 타입이라 전부 해당됩니다.

  ---
  2. ? — 와일드카드

  ?는 "어떤 타입인지 모르겠지만 아무 타입" 이라는 뜻입니다.

  Collection<?>  // 뭐든 담긴 컬렉션 (String이든 Integer든 상관없음)

  ---
  3. ? extends X — 상한 와일드카드 (Upper Bounded Wildcard)

  핵심입니다. "X이거나, X를 상속한 하위 타입" 이라는 뜻입니다.

  Collection<? extends GrantedAuthority>

  GrantedAuthority이거나, GrantedAuthority를 상속/구현한 어떤 타입이든 OK

  ---
  왜 이렇게 쓸까?

  GrantedAuthority는 인터페이스이고, 구현체가 여러 개 있습니다:

  GrantedAuthority (인터페이스)
     ├── SimpleGrantedAuthority
     ├── 내가 만든 CustomAuthority
     └── 기타 구현체들...

  만약 반환 타입이 Collection<GrantedAuthority>로 고정되어 있으면:

  // 컴파일 에러!
  List<SimpleGrantedAuthority> list = List.of(new SimpleGrantedAuthority("ROLE_USER"));
  return list;  // List<SimpleGrantedAuthority>는 Collection<GrantedAuthority>가 아님

  List<SimpleGrantedAuthority>는 Collection<GrantedAuthority>에 대입할 수 없습니다. 제네릭은 상속 관계가 전이되지 않기 때문입니다. (List<자식> ≠ List<부모>)

  하지만 ? extends를 쓰면:

  // 정상 동작!
  List<SimpleGrantedAuthority> list = List.of(new SimpleGrantedAuthority("ROLE_USER"));
  return list;  // List<SimpleGrantedAuthority>는 Collection<? extends GrantedAuthority>에 대입 가능

  ---
  실제 사용 예시

  // 방법 1: List<GrantedAuthority>로 반환
  @Override
  public Collection<? extends GrantedAuthority> getAuthorities() {
      return List.of(new SimpleGrantedAuthority("user"));
  }

  // 방법 2: List<SimpleGrantedAuthority>로 반환 — 이것도 OK
  @Override
  public Collection<? extends GrantedAuthority> getAuthorities() {
      List<SimpleGrantedAuthority> authorities = new ArrayList<>();
      authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
      authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
      return authorities;  // ? extends 덕분에 가능
  }

  ---
  비유로 정리
  ┌────────────────────────────────────────┬────────────────────────────────────┬─────────────────────────────────────────────────┐
  │                  문법                  │                의미                │                      비유                       │
  ├────────────────────────────────────────┼────────────────────────────────────┼─────────────────────────────────────────────────┤
  │ Collection<GrantedAuthority>           │ 정확히 GrantedAuthority만          │ "사과만 담는 바구니"                            │
  ├────────────────────────────────────────┼────────────────────────────────────┼─────────────────────────────────────────────────┤
  │ Collection<? extends GrantedAuthority> │ GrantedAuthority 또는 그 하위 타입 │ "사과 종류면 다 담는 바구니" (부사, 홍옥 등)    │
  ├────────────────────────────────────────┼────────────────────────────────────┼─────────────────────────────────────────────────┤
  │ Collection<?>                          │ 아무 타입                          │ "아무거나 담긴 바구니"                          │
  ├────────────────────────────────────────┼────────────────────────────────────┼─────────────────────────────────────────────────┤
  │ Collection<? super GrantedAuthority>   │ GrantedAuthority 또는 그 상위 타입 │ "사과보다 넓은 카테고리 바구니" (과일, 음식 등) │
  └────────────────────────────────────────┴────────────────────────────────────┴─────────────────────────────────────────────────┘
  핵심은 ? extends는 읽기(반환)용, ? super는 쓰기(입력)용으로 많이 쓰입니다. 여기서는 권한 목록을 반환하는 메서드이므로 ? extends가 쓰인 것입니다.


  UserDetails: 스프링 시큐리티에서 사용자의 인증 정보를 담아두는 "인터페이스" -> 오버라이드 메서드 사용 필수.

세션 기반 인증과 토큰 기반 인증

세션 기반 인증: 서버에서 사용자의 정보를 담은 세션을 생성하고 저장
토큰 기반 인증: 토큰을 클라이언트에 저장하고, 이후 요청을 보낼 때마다 토큰을 서버에 전달

토큰 기반 인증의 특징
1. 무상태성: 서버는 클라이언트의 상태를 저장하지 않음
2. 확장성: 서버를 늘리기 쉬움
3. 무결성: HMAC(Hash-based Message Authentication Code)을 통해 토큰의 위변조를 방지


JWT 토큰

JWT 토큰을 통해 인증을 하기 위해서는 HTTP 요청 헤더에 Authorization 헤더에 토큰을 담아서 보내야 합니다.

Authorization: Bearer <token>

JWT 토큰의 구조

JWT 토큰은 헤더, 페이로드, 서명의 세 부분으로 구성됩니다.

헤더: 토큰의 타입과 서명 알고리즘을 지정
페이로드: 토큰의 내용을 담고 있음
서명: 토큰의 위변조를 방지  

헤더의 구성:
typ: 토큰의 타입 (jwt의 경우 문자열)
alg: 서명 알고리즘 (해싱 알고리즘 지정)

ex>
{
    "typ": "JWT",
    "alg": "HS256"
}


페이로드(토큰): 토큰의 내용을 담고 있음
클레임: 페이로드의 한 덩어리
등록된 클레임, 공개 클레임, 비공개 클레임으로 구성됨

등록된 클레임의 예시
iss: 발급자
sub: 주제
exp: 만료 시간
nbf: 활성 시간
iat: 발급 시간
jti: 토큰 식별자

공개 클레임: 페이로드에 포함할 수 있는 클레임 (url로 표기)
비공개 클레임: 페이로드에 포함할 수 없는 클레임 (url로 표기하지 않음)

ex> 
{
    "iss": "https://example.com", // 등록된 클레임
    "sub": "1234567890", // 등록된 클레임
    "exp": 1516239022, // 등록된 클레임
    "http://example.com/claim": "true" // 공개 클레임
    "email": "user@example.com" // 비공개 클레임
    "role": "user" // 비공개 클레임
}

시그니처(서명): 해당 토큰이 조작되었거나 변경되지 않았음을 증명하는 값. 헤더의 인코딩 값과 내용의 인코딩을 합침 -> 주어진 비밀키를 사용하여 해싱한 값

토큰의 취약점: 토큰은 클라이언트에 저장되어 있어야 하므로, 해커가 토큰을 획득할 수 있습니다.
따라서 토큰은 엑세스 토큰과 리프레시 토큰을 따로 생성해 관리
엑세스 토큰: 사용자 인증을 위한 토큰
리프레시 토큰: 엑세스 토큰이 만료되면 새로운 엑세스 토큰을 발급하기 위한 토큰

클라이언트가 서버에 인증을 요청하면, 엑세스 토큰과 리프레시 토큰을 모두 발급합니다.

만료된 엑세스 토큰을 사용하여 API를 호출하면 서버는 에러를 발생시키고, 사용자는 엑세스 토큰을 다시 발급받을 수 있도록 리프레시 토큰을 사용하여 API를 호출합니다.

토큰 필터: HTTP 요청이 컨트롤러에 도달하기 전에 토큰을 검증하는 필터
시큐리티 컨텍스트: 시큐리티 컨텍스트에 인증 정보를 저장. 스레드 로컬에 저장되어 스레드가 종료되면 자동으로 삭제되고, 코드 아무곳에서나 참조할 수 있음. 다른 스레드와는 공유하지 않음.
시큐리티 컨텍스트 홀더가 시큐리티 컨텍스트 객체를 저장함.

