# Spring Boot 테스트 & JPA 학습 정리

## 📌 1. 테스트 코드 관련 어노테이션

### 1.1 테스트 환경 설정 어노테이션

#### `@SpringBootTest`
- **역할**: 통합 테스트 환경 구성
- **동작 방식**: 
  - `@SpringBootApplication`이 붙은 메인 클래스를 찾음
  - 해당 클래스에 등록된 모든 빈(Bean)을 로드
  - 실제 애플리케이션과 동일한 테스트용 컨텍스트 생성
- **사용 시기**: 전체 애플리케이션을 테스트할 때

#### `@AutoConfigureMockMvc`
- **역할**: MockMvc 자동 생성 및 구성
- **특징**: 
  - 실제 서버 배포 없이 테스트용 MVC 환경 제공
  - 컨트롤러 레이어 테스트에 주로 사용
  - HTTP 요청/응답을 시뮬레이션

> **💡 MVC 패턴이란?**
> - **Model**: 데이터 처리 객체 (비즈니스 로직, 데이터)
> - **View**: 데이터 표시 객체 (사용자 인터페이스)
> - **Controller**: Model과 View를 연결하는 중개자

### 1.2 테스트 메서드 어노테이션

| 어노테이션 | 실행 시점 | 실행 횟수 | 주요 용도 |
|-----------|----------|----------|----------|
| `@BeforeAll` | 모든 테스트 시작 전 | 1회 | DB 연결, 전역 설정 초기화 |
| `@BeforeEach` | 각 테스트 메서드 실행 전 | 매번 | 테스트 데이터 준비, 객체 초기화 |
| `@Test` | 실제 테스트 로직 실행 | - | 테스트할 기능 작성 |
| `@AfterEach` | 각 테스트 메서드 실행 후 | 매번 | 테스트 데이터 정리 |
| `@AfterAll` | 모든 테스트 종료 후 | 1회 | 자원 해제, 연결 종료 |
| `@DisplayName` | - | - | 테스트 이름 한글로 표시 |

**실행 순서 예시:**
```
@BeforeAll (1회)
  ↓
@BeforeEach → @Test(테스트1) → @AfterEach
  ↓
@BeforeEach → @Test(테스트2) → @AfterEach
  ↓
@BeforeAll (1회)
```

---

## 📌 2. 테스트 코드 주요 메서드

### 2.1 MockMvc 관련 메서드

#### `perform()`
- **역할**: HTTP 요청을 전송
- **반환값**: `ResultActions` 객체
- **특징**: 이어서 검증 메서드 체이닝 가능

```java
mockMvc.perform(get("/api/articles"))  // GET 요청 보내기
       .andExpect(status().isOk());     // 응답 검증
```

#### `accept()`
- **역할**: 응답으로 받을 데이터 타입 지정
- **예시**: `accept(MediaType.APPLICATION_JSON)` - JSON 응답 요청

#### `andExpect()`
- **역할**: 응답 결과 검증
- **주요 검증 항목**:
  - `status().isOk()`: HTTP 상태 코드 200 확인
  - `status().isCreated()`: HTTP 상태 코드 201 확인
  - `jsonPath()`: JSON 응답 데이터 검증

#### `jsonPath("$[0].${field}")`
- **역할**: JSON 응답의 특정 필드 값 추출 및 검증
- **문법**: 
  - `$`: 루트
  - `[0]`: 배열의 첫 번째 요소
  - `.field`: 객체의 특정 필드
- **예시**: `jsonPath("$[0].title").value("제목")`

---

## 📌 3. 레코드(Record)

### 개념
자바 14에서 도입된 데이터 전달 전용 클래스

### 자동 생성 항목
1. 모든 필드 (final, private)
2. 생성자 (모든 필드를 받는)
3. Getter 메서드
4. `equals()`, `hashCode()`, `toString()`

### 사용 예시
```java
// 레코드 정의
public record ArticleDto(String title, String content) {}

// 사용
ArticleDto dto = new ArticleDto("제목", "내용");
String title = dto.title();  // getter는 getTitle()이 아닌 title()
```

### 장점
- 불변 객체 (한번 생성하면 수정 불가)
- 간결한 코드 (보일러플레이트 제거)
- DTO(Data Transfer Object)로 적합

---

## 📌 4. ObjectMapper

### 개념
Jackson 라이브러리의 핵심 클래스로, Java 객체와 JSON 간 변환 담당

### 주요 메서드

#### `writeValueAsString(Object)`
Java 객체 → JSON 문자열 (직렬화)
```java
Article article = new Article("제목", "내용");
String json = objectMapper.writeValueAsString(article);
// 결과: {"title":"제목","content":"내용"}
```

#### `readValue(String, Class)`
JSON 문자열 → Java 객체 (역직렬화)
```java
String json = "{\"title\":\"제목\",\"content\":\"내용\"}";
Article article = objectMapper.readValue(json, Article.class);
```

### 사용 목적
- API 테스트 시 요청 본문(body)을 JSON으로 변환
- API 응답 JSON을 Java 객체로 변환

---

## 📌 5. H2 데이터베이스

### 개념
스프링 부트가 지원하는 **인메모리 관계형 데이터베이스**

### 특징
- 메모리에서 실행 (별도 설치 불필요)
- 애플리케이션 시작 시 생성, 종료 시 데이터 소멸
- 빠른 속도 (메모리 기반)
- 개발/테스트 환경에 최적화

### H2 콘솔
- **접속 주소**: `http://localhost:8080/h2-console`
- **기능**: 
  - 테이블 구조 확인
  - SQL 직접 실행
  - 데이터 조회/수정

### 활성화 방법
```yaml
# application.yml
spring:
  h2:
    console:
      enabled: true  # H2 콘솔 활성화
```

> **⚠️ 주의**: 운영 환경에서는 반드시 `enabled: false`로 설정 (보안 이슈)

---

## 📌 6. ORM과 JPA

### 6.1 ORM (Object Relational Mapping)

#### 개념
자바 객체와 데이터베이스 테이블을 자동으로 매핑하는 기술

#### 장점
- SQL 작성 없이 자바 코드만으로 DB 작업 가능
- 데이터베이스 독립성 (MySQL, PostgreSQL 등 변경 용이)
- 생산성 향상

#### 비유
```
개발자(자바 코드) → ORM(번역기) → 데이터베이스(SQL)
```

### 6.2 JPA (Java Persistence API)

#### 개념
자바에서 **ORM을 사용하는 방식을 정의한 표준 인터페이스**

#### 특징
- 인터페이스이므로 구현체가 필요
- 대표 구현체: **Hibernate**

#### 관계도
```
애플리케이션
    ↓
  JPA (인터페이스)
    ↓
Hibernate (구현체)
    ↓
 JDBC API
    ↓
데이터베이스
```

### 6.3 Hibernate

#### 개념
- JPA 명세를 구현한 ORM 프레임워크
- 자바용 ORM의 사실상 표준

#### 동작 방식
내부적으로 JDBC API를 사용하여 데이터베이스와 통신

---

## 📌 7. 엔티티 (Entity)

### 개념
데이터베이스 테이블과 매핑되는 자바 객체

### 특징
- 일반 자바 객체(POJO)와 본질적으로 동일
- `@Entity` 어노테이션으로 표시
- 데이터베이스 테이블과 1:1 매핑
- **쿼리를 실행하는 자바 객체**

### 엔티티 예시
```java
@Entity
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    @Column(nullable = false)
    private String content;
    
    // 생성자, getter, setter
}
```

---

## 📌 8. 엔티티 매니저와 영속성 컨텍스트

### 8.1 엔티티 매니저 (EntityManager)

#### 역할
- 엔티티를 관리하여 데이터베이스 CRUD 수행
- 영속성 컨텍스트와의 인터페이스

#### 엔티티 매니저 팩토리
- 엔티티 매니저를 생성하는 공장
- 스프링 부트는 내부에서 **하나만 생성하여 공유**

#### 주입 방법
```java
@PersistenceContext  // 또는 @Autowired
EntityManager em;
```

### 8.2 동작 과정

```
클라이언트 요청
    ↓
엔티티 매니저 팩토리
    ↓
엔티티 매니저 생성
    ↓
데이터베이스 커넥션 획득
    ↓
쿼리 실행
```

### 8.3 영속성 컨텍스트

#### 개념
엔티티를 관리하는 **가상의 메모리 공간**

#### 4가지 특징

##### 1️⃣ 1차 캐시
- 엔티티를 메모리에 캐싱
- 키: `@Id` 필드 (기본키)
- 값: 엔티티 객체

**장점**: 같은 엔티티 조회 시 DB 접근 없이 캐시에서 반환

##### 2️⃣ 쓰기 지연 (Write-Behind)
- 트랜잭션 커밋 전까지 쿼리를 모았다가
- 커밋 시점에 한번에 DB로 전송

**장점**: 네트워크 호출 횟수 감소

##### 3️⃣ 변경 감지 (Dirty Checking)
- 트랜잭션 커밋 시 1차 캐시의 엔티티와 현재 엔티티를 비교
- 변경 사항을 자동으로 UPDATE 쿼리로 반영

**장점**: 별도의 `update()` 메서드 호출 불필요

##### 4️⃣ 지연 로딩 (Lazy Loading)
- 연관된 엔티티를 실제 사용 시점에 조회
- 불필요한 조인 방지

---

## 📌 9. 엔티티의 4가지 상태

### 상태 다이어그램
```
[Transient] ──persist()──→ [Managed] ──detach()──→ [Detached]
                              ↓
                          remove()
                              ↓
                          [Removed]
```

### 상태 설명

| 상태 | 영문 | 설명 | 예시 |
|-----|------|------|------|
| 비영속 | Transient | 영속성 컨텍스트와 무관한 새 객체 | `new Article()` |
| 영속 | Managed | 영속성 컨텍스트가 관리하는 객체 | `em.persist(article)` 후 |
| 준영속 | Detached | 영속성 컨텍스트에서 분리된 객체 | `em.detach(article)` 후 |
| 삭제 | Removed | 삭제 예정인 객체 | `em.remove(article)` 후 |

### 상태 변경 메서드

```java
// 비영속 → 영속
em.persist(article);

// 영속 → 준영속
em.detach(article);

// 영속 → 삭제
em.remove(article);
```

---

## 📌 10. 스프링 데이터 JPA

### 10.1 개념

#### 스프링 데이터 (Spring Data)
JPA, MongoDB, Redis 등 다양한 데이터 저장소를 위한 공통 인터페이스 제공

#### 스프링 데이터 JPA
스프링 데이터의 JPA 특화 버전

### 10.2 리포지토리 인터페이스

#### 기본 사용법
```java
public interface ArticleRepository extends JpaRepository<Article, Long> {
    // 메서드 선언 없이도 기본 CRUD 사용 가능
}
```

#### 제네릭 타입
- 첫 번째: 엔티티 타입 (`Article`)
- 두 번째: 기본키 타입 (`Long`)

### 10.3 주요 메서드

| 메서드 | 기능 | 반환 타입 |
|-------|------|----------|
| `save(entity)` | 엔티티 저장/수정 | 저장된 엔티티 |
| `findById(id)` | ID로 조회 | `Optional<Entity>` |
| `findAll()` | 전체 조회 | `List<Entity>` |
| `saveAll(entities)` | 여러 엔티티 저장 | `List<Entity>` |
| `deleteById(id)` | ID로 삭제 | void |
| `deleteAll()` | 전체 삭제 | void |
| `count()` | 개수 조회 | long |
| `existsById(id)` | 존재 여부 | boolean |

### 10.4 @DataJpaTest

#### 특징
- JPA 관련 컴포넌트만 로드 (가벼운 테스트)
- `@Transactional` 자동 적용
- 각 테스트 후 자동 롤백

#### 변경 감지 주의사항
```java
@DataJpaTest
class ArticleRepositoryTest {
    @Test
    void updateTest() {
        Article article = articleRepository.findById(1L).get();
        article.setTitle("수정된 제목");
        // save() 호출 없어도 자동으로 UPDATE 실행됨
    }
}
```

> **⚠️ 중요**: 서비스 계층에서 업데이트 기능 사용 시 반드시 `@Transactional` 필요!

---

## 📌 11. REST API

### 11.1 개념

#### REST (Representational State Transfer)
자원을 이름으로 구분하여 자원의 상태를 주고받는 아키텍처 스타일

#### 특징
- **무상태성(Stateless)**: 서버가 클라이언트 상태를 저장하지 않음
- **자원 기반**: URL로 자원을 표현
- **표준 HTTP 메서드 사용**: GET, POST, PUT, DELETE

### 11.2 REST API 설계 원칙

#### ✅ 규칙 1: URL에는 자원만, 동사는 사용 금지

**좋은 예시:**
```
GET /students/1        # ID가 1인 학생 조회
POST /students         # 학생 생성
PUT /students/1        # ID가 1인 학생 수정
DELETE /students/1     # ID가 1인 학생 삭제
```

**나쁜 예시:**
```
GET /getStudent?id=1          # ❌ 동사 사용
POST /createStudent           # ❌ 동사 사용
PUT /updateStudent?id=1       # ❌ 동사 사용
DELETE /deleteStudent?id=1    # ❌ 동사 사용
```

#### ✅ 규칙 2: 동사는 HTTP 메서드로 표현

| HTTP 메서드 | 용도 | SQL 대응 |
|------------|------|---------|
| GET | 자원 조회 | SELECT |
| POST | 자원 생성 | INSERT |
| PUT | 자원 전체 수정 | UPDATE |
| PATCH | 자원 일부 수정 | UPDATE |
| DELETE | 자원 삭제 | DELETE |

#### ✅ 규칙 3: 계층 관계는 슬래시(/)로 표현

```
GET /schools/1/students       # 1번 학교의 학생들
GET /students/1/grades        # 1번 학생의 성적들
```

#### ✅ 규칙 4: 밑줄(_) 대신 하이픈(-)

```
✅ /student-grades
❌ /student_grades
```

#### ✅ 규칙 5: 컬렉션과 문서 구분

- **컬렉션 (여러 개)**: 복수형 사용
- **문서 (단일)**: 단수형 사용

```
GET /articles          # 여러 게시글 (컬렉션)
GET /articles/1        # 특정 게시글 (문서)
```

### 11.3 HTTP 상태 코드

#### 성공 응답 (2xx)
| 코드 | 의미 | 사용 시점 |
|-----|------|----------|
| 200 OK | 요청 성공 | GET, PUT, PATCH 성공 |
| 201 Created | 자원 생성 성공 | POST 성공 |
| 204 No Content | 성공했으나 응답 본문 없음 | DELETE 성공 |

#### 클라이언트 오류 (4xx)
| 코드 | 의미 | 사용 시점 |
|-----|------|----------|
| 400 Bad Request | 잘못된 요청 | 유효성 검증 실패 |
| 401 Unauthorized | 인증 필요 | 로그인 필요 |
| 403 Forbidden | 권한 없음 | 접근 권한 부족 |
| 404 Not Found | 자원 없음 | 존재하지 않는 ID |

#### 서버 오류 (5xx)
| 코드 | 의미 | 사용 시점 |
|-----|------|----------|
| 500 Internal Server Error | 서버 오류 | 예상치 못한 예외 |
| 503 Service Unavailable | 서비스 불가 | 서버 점검 중 |

---

## 📌 12. 빌더 패턴 (@Builder)

### 12.1 개념

#### 빌더가 하는 일
생성자를 호출하는 더 읽기 쉬운 방법 제공

#### 코드 비교
```java
// 일반 생성자
Article article = new Article("제목", "내용");

// 빌더 패턴
Article article = Article.builder()
    .title("제목")
    .content("내용")
    .build();
```

### 12.2 장점

1. **가독성**: 각 필드의 의미가 명확
2. **선택적 파라미터**: 필요한 필드만 설정 가능
3. **불변 객체**: 생성 후 수정 불가능한 안전한 객체 생성

### 12.3 실제 구현

```java
@Entity
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    
    protected Article() {}  // JPA용 기본 생성자
    
    @Builder  // 이 어노테이션이 빌더 메서드 생성
    public Article(String title, String content) {
        this.title = title;
        this.content = content;
    }
}
```

#### 내부 동작
```java
// 빌더가 결국 아래 생성자를 호출함
Article.builder()
    .title("제목")
    .content("내용")
    .build();

// ↓ 내부적으로 변환됨 ↓

new Article("제목", "내용");
```

---

## 📌 13. JPA 필수 생성자

### 13.1 왜 기본 생성자가 필요한가?

#### JPA의 객체 생성 방식
```java
// 1단계: 기본 생성자로 빈 객체 생성
Article article = new Article();

// 2단계: 리플렉션으로 필드에 값 주입
article.title = "DB에서 읽은 제목";
article.content = "DB에서 읽은 내용";
```

> 기본 생성자가 없으면 1단계에서 오류 발생!

### 13.2 왜 protected인가?

```java
protected Article() {}  // ✅ JPA는 접근 가능, 개발자는 사용 금지
```

#### 접근 제한자별 차이

| 접근 제한자 | JPA 접근 | 일반 코드 접근 | 문제점 |
|-----------|---------|---------------|--------|
| `public` | ✅ 가능 | ✅ 가능 | 의도치 않은 빈 객체 생성 가능 |
| `protected` | ✅ 가능 | ❌ 불가능 | JPA만 사용, 개발자는 빌더 사용 강제 |
| `private` | ❌ 불가능 | ❌ 불가능 | JPA 오류 발생 |

### 13.3 전체 생성자 구조

```java
@Entity
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    
    // JPA 전용 (개발자 사용 금지)
    protected Article() {}
    
    // 개발자 전용 (빌더가 이 생성자 호출)
    @Builder
    public Article(String title, String content) {
        this.title = title;
        this.content = content;
    }
}
```

---

## 📌 14. Getter와 캡슐화

### 14.1 왜 Getter를 사용하는가?

#### private 필드의 문제
```java
public class Article {
    private String title;  // 외부에서 접근 불가
}

Article article = new Article("제목");
System.out.println(article.title);  // ❌ 컴파일 에러
```

#### Getter로 해결
```java
public class Article {
    private String title;
    
    public String getTitle() {  // 읽기 전용 통로
        return title;
    }
}

System.out.println(article.getTitle());  // ✅ "제목"
```

### 14.2 왜 public 필드를 쓰지 않나?

#### public 필드의 문제점
```java
public String title;  // 누구나 수정 가능

article.title = "";     // 빈 문자열 가능
article.title = null;   // null 가능
// 검증 로직 없음!
```

#### private + Getter의 장점
```java
private String title;

public String getTitle() {
    return title;  // 읽기만 가능
}
// setter가 없으면 수정 불가 → 불변성 보장
```

### 14.3 Lombok으로 간편하게

```java
@Getter  // 모든 필드의 Getter 자동 생성
public class Article {
    private Long id;
    private String title;
    private String content;
    
    // getId(), getTitle(), getContent() 자동 생성됨
}
```

---

## 📌 15. 테스트 환경 세팅 코드 상세 분석

### 15.1 클래스 레벨 어노테이션

```java
@SpringBootTest
@AutoConfigureMockMvc
public class ArticleApiControllerTest {
```

- `@SpringBootTest`: 실제 Spring Boot 애플리케이션 전체를 띄움
- `@AutoConfigureMockMvc`: HTTP 요청 시뮬레이션 도구 자동 생성

### 15.2 필드 주입

```java
@Autowired
protected MockMvc mockMvc;
```
- **역할**: 가짜 HTTP 요청을 보내는 테스트 도구
- **사용 예시**:
```java
mockMvc.perform(get("/api/articles"))
       .andExpect(status().isOk());
```

```java
@Autowired
protected ObjectMapper objectMapper;
```
- **역할**: Java 객체 ↔ JSON 변환기
- **사용 예시**:
```java
String json = objectMapper.writeValueAsString(article);
```

```java
@Autowired
private WebApplicationContext context;
```
- **역할**: Spring 애플리케이션의 전체 설정 정보 보관
- **사용 시점**: MockMvc 생성 시

```java
@Autowired
BlogRepository blogRepository;
```
- **역할**: 데이터베이스 접근 인터페이스
- **사용 예시**: 테스트 데이터 삽입/삭제

### 15.3 테스트 초기화

```java
@BeforeEach
public void mockMvcSetUp() {
    this.mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .build();
    
    blogRepository.deleteAll();
}
```

#### 실행 흐름
```
테스트1 실행 전 → mockMvcSetUp() 실행
                → MockMvc 새로 생성
                → DB 데이터 전체 삭제
                → 테스트1 실행
                
테스트2 실행 전 → mockMvcSetUp() 실행
                → MockMvc 새로 생성
                → DB 데이터 전체 삭제
                → 테스트2 실행
```

#### 왜 매번 DB를 비우나?
- **테스트 독립성 보장**: 이전 테스트의 데이터가 다음 테스트에 영향을 주지 않도록
- **예측 가능한 환경**: 항상 같은 초기 상태에서 테스트 시작

---

## 📌 16. 학습 테스트 (Learning Test)

### 개념
사용하는 라이브러리나 프레임워크의 기능을 검증하며 동작 원리를 파악하는 테스트

### 목적
- 새로운 기술 학습
- 예상대로 동작하는지 확인
- 업데이트 시 동작 변경 여부 감지

### 예시
```java
@Test
@DisplayName("JPA save 메서드 학습 테스트")
void jpaRepositorySaveTest() {
    // given
    Article article = Article.builder()
        .title("제목")
        .content("내용")
        .build();
    
    // when
    Article saved = articleRepository.save(article);
    
    // then
    assertThat(saved.getId()).isNotNull();
}
```

---

## 📚 핵심 요약

### 테스트 코드
- `@SpringBootTest` + `@AutoConfigureMockMvc` → 통합 테스트 환경
- `MockMvc`로 HTTP 요청 시뮬레이션
- `@BeforeEach`로 각 테스트 전 초기화

### JPA 핵심
- **엔티티**: DB 테이블과 매핑된 자바 객체
- **엔티티 매니저**: 엔티티 CRUD 담당
- **영속성 컨텍스트**: 엔티티 관리 공간 (1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩)

### 스프링 데이터 JPA
- `JpaRepository` 상속만으로 기본 CRUD 제공
- `save()`, `findById()`, `findAll()`, `deleteById()` 등

### REST API
- URL에는 자원만, 동사는 HTTP 메서드로
- GET(조회), POST(생성), PUT(수정), DELETE(삭제)
- 상태 코드로 결과 표현 (200, 201, 404, 500 등)

### 설계 패턴
- **빌더 패턴**: 가독성 높은 객체 생성
- **캡슐화**: private 필드 + public getter
- **불변 객체**: setter 없이 생성 시점에만 값 설정