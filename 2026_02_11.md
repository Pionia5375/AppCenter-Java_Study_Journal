# 소켓 통신, HTTP, Stateless의 이해

---

## 1. 소켓 (Socket) 통신

### 소켓이란?
- 네트워크에서 두 프로그램이 데이터를 주고받기 위한 **양쪽 끝점(endpoint)** 이다.
- **IP 주소 + 포트 번호**의 조합으로 식별된다. (ex. `192.168.0.1:8080`)
- 운영체제가 제공하는 저수준 네트워크 인터페이스이다.
- 모든 네트워크 통신의 기반이 된다. HTTP, WebSocket, DB 연결 등 결국 밑바닥에는 소켓이 있다.

### TCP 소켓 (연결 지향)
- **연결 지향적(connection-oriented)** 방식이다.
- 데이터를 보내기 전에 먼저 **3-way handshake**로 연결을 수립한다.
  ```
  [3-way handshake]
  클라이언트 → 서버 : SYN (연결 요청)
  서버 → 클라이언트 : SYN-ACK (요청 수락)
  클라이언트 → 서버 : ACK (확인)
  → 연결 수립 완료, 이후 데이터 전송 시작
  ```
- 데이터의 **순서 보장**, 손실 시 **재전송**, **흐름 제어**가 이루어진다.
- 신뢰성이 높다. → 웹(HTTP), 이메일, 파일 전송 등에 사용된다.

### UDP 소켓 (비연결)
- **비연결(connectionless)** 방식이다. 연결 수립 없이 바로 데이터를 보낸다.
- 순서 보장이나 재전송이 없다. → 신뢰성은 낮지만 그만큼 **빠르다**.
- 실시간 스트리밍, 온라인 게임, DNS 조회, VoIP 등에 사용된다.

### TCP vs UDP 비교

| | TCP | UDP |
|--|-----|-----|
| 연결 방식 | 연결 수립 후 통신 (3-way handshake) | 연결 없이 바로 전송 |
| 신뢰성 | 높음 (순서 보장, 재전송) | 낮음 (순서/도착 보장 안 됨) |
| 속도 | 상대적으로 느림 | 빠름 |
| 용도 | 웹(HTTP), 이메일, 파일 전송 | 스트리밍, 게임, DNS |

### 소켓 통신의 핵심 특징
- 연결이 유지되는 동안(TCP의 경우) **양방향 통신**이 자유롭다.
- 서버와 클라이언트가 연결을 끊지 않는 한 언제든 데이터를 주고받을 수 있다.

---

## 2. HTTP의 등장 배경

### 소켓 직접 사용의 문제
- 초기 인터넷에서는 소켓을 직접 다뤄야 했기 때문에 통신 규약이 제각각이었다.
- 프로그램마다 "데이터를 어떤 형식으로 보낼지", "어떤 순서로 대화할지"가 달랐다.

### HTTP의 탄생
- 1989년 팀 버너스리(Tim Berners-Lee)가 웹을 고안하면서, 문서(하이퍼텍스트)를 주고받기 위한 **표준 프로토콜**이 필요해졌다.
- 이것이 **HTTP(HyperText Transfer Protocol)** 이다.

### 소켓과 HTTP의 관계
- HTTP는 **TCP 소켓 위에서 동작하는 응용 계층(Application Layer) 프로토콜**이다.
- 내부적으로는 TCP 소켓 통신을 사용하지만, 개발자가 직접 소켓을 다룰 필요 없이 정해진 규칙(요청-응답 형식, 헤더, 메서드 등)에 따라 통신할 수 있게 해준다.
- HTTP가 TCP를 사용하는 이유: 웹에서는 HTML, 이미지 등의 데이터가 **정확하고 완전하게** 전달되어야 하므로, 신뢰성 있는 TCP를 기반으로 한다.

```
[네트워크 계층 구조에서의 위치]
응용 계층     :  HTTP, HTTPS, FTP, SMTP ...
전송 계층     :  TCP, UDP
인터넷 계층   :  IP
네트워크 계층  :  이더넷, Wi-Fi ...
```

> 비유: 소켓이 "전화기"라면, HTTP는 "전화 예절 매뉴얼"이다. 소켓이라는 물리적 수단 위에 HTTP라는 약속된 대화 규칙을 얹은 것이다.

---

## 3. HTTP의 동작 방식: 요청과 응답

HTTP는 **요청(Request) - 응답(Response)** 구조로 동작한다. 클라이언트가 요청을 보내면, 서버가 응답을 돌려주는 단방향 흐름이다.

### HTTP 요청 (Request) 구조
```
[요청 라인]   GET /members/1 HTTP/1.1
[헤더]        Host: localhost:8080
              Accept: application/json
              Authorization: Bearer abc123
[빈 줄]
[본문(Body)]  (GET 요청은 보통 본문이 없음)
```

- **요청 라인**: 메서드 + URL + HTTP 버전
- **헤더**: 요청에 대한 부가 정보 (인증 정보, 데이터 형식 등)
- **본문**: 서버에 전달할 데이터 (POST, PUT 등에서 사용)

### HTTP 응답 (Response) 구조
```
[상태 라인]   HTTP/1.1 200 OK
[헤더]        Content-Type: application/json
              Content-Length: 52
[빈 줄]
[본문(Body)]  {"id": 1, "name": "홍길동"}
```

- **상태 라인**: HTTP 버전 + 상태 코드 + 상태 메시지
- **헤더**: 응답에 대한 부가 정보 (데이터 타입, 길이 등)
- **본문**: 실제 응답 데이터

---

## 4. HTTP 메서드

클라이언트가 서버에게 **어떤 동작을 원하는지** 표현하는 수단이다.

| 메서드 | 역할 | CRUD 대응 | 예시 |
|--------|------|-----------|------|
| **GET** | 리소스 조회 | Read | `GET /members/1` |
| **POST** | 리소스 생성 | Create | `POST /members` (본문에 데이터) |
| **PUT** | 리소스 전체 수정 | Update | `PUT /members/1` (본문에 전체 데이터) |
| **PATCH** | 리소스 부분 수정 | Update | `PATCH /members/1` (본문에 변경 부분만) |
| **DELETE** | 리소스 삭제 | Delete | `DELETE /members/1` |

### 주요 특성

**안전(Safe)**
- 서버의 상태를 변경하지 않는 메서드이다.
- GET은 안전하다. (조회만 하므로) POST, PUT, DELETE는 안전하지 않다.

**멱등(Idempotent)**
- 같은 요청을 여러 번 보내도 결과가 같은 메서드이다.
- GET, PUT, DELETE는 멱등하다. (같은 GET을 10번 해도 결과는 같다)
- POST는 멱등하지 않다. (같은 POST를 10번 하면 10개가 생성될 수 있다)

---

## 5. HTTP 상태 코드

서버가 요청 처리 결과를 **숫자 3자리**로 알려주는 코드이다.

| 범위 | 의미 | 대표 코드 |
|------|------|-----------|
| **1xx** | 정보 | `100 Continue` |
| **2xx** | 성공 | `200 OK`, `201 Created`, `204 No Content` |
| **3xx** | 리다이렉션 | `301 Moved Permanently`, `302 Found` |
| **4xx** | 클라이언트 오류 | `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found` |
| **5xx** | 서버 오류 | `500 Internal Server Error`, `503 Service Unavailable` |

자주 마주치는 코드:
- **200 OK**: 요청 성공
- **201 Created**: 리소스 생성 성공 (POST 요청의 성공 응답)
- **400 Bad Request**: 잘못된 요청 (파라미터 오류, 유효성 검증 실패 등)
- **401 Unauthorized**: 인증 필요 (로그인하지 않음)
- **403 Forbidden**: 인증은 됐지만 권한 부족
- **404 Not Found**: 요청한 리소스가 존재하지 않음
- **500 Internal Server Error**: 서버 내부 오류

---

## 6. HTTP의 핵심 특징: Stateless (무상태)

### Stateless란?
- 서버가 클라이언트의 **이전 요청을 전혀 기억하지 않는다**는 뜻이다.
- 매 요청은 완전히 독립적이며, 이전에 어떤 요청을 했는지와 무관하게 처리된다.

### 예시
쇼핑몰에서 `로그인 → 상품 조회 → 장바구니 담기`를 한다고 하면:
- 순수한 HTTP에서는 서버 입장에서 이 세 요청이 같은 사람인지 알 수 없다.
- 매번 "나는 누구이고, 무엇을 원한다"는 정보를 요청에 모두 담아 보내야 한다.

### 왜 Stateless로 설계했는가?

**1. 확장성 (Scalability)**
- 서버가 클라이언트의 상태를 저장하지 않으므로, **어떤 서버가 요청을 받아도** 동일하게 처리할 수 있다.
- 서버를 수십, 수백 대로 늘려도 문제가 없다.
- Stateful이라면 "이 클라이언트는 반드시 3번 서버로 보내야 해"라는 제약이 생긴다.

```
[Stateless의 확장성]
클라이언트 → 로드밸런서 → 서버1 (요청 A 처리)
클라이언트 → 로드밸런서 → 서버2 (요청 B 처리)  ← 다른 서버여도 OK
클라이언트 → 로드밸런서 → 서버3 (요청 C 처리)  ← 다른 서버여도 OK
```

**2. 단순성과 신뢰성**
- 서버가 중간에 장애가 나더라도 다른 서버가 바로 대체할 수 있다.
- 서버 간 상태 동기화 문제를 고민할 필요가 없다.

### Stateless의 한계와 보완

현실적으로 로그인 상태 유지, 장바구니 등은 상태가 필요하다. 이를 보완하기 위해 다음 기술들이 등장했다.

| 기술 | 저장 위치 | 동작 방식 |
|------|-----------|-----------|
| **쿠키 (Cookie)** | 클라이언트(브라우저) | 서버가 클라이언트에게 작은 데이터를 저장시키고, 매 요청마다 자동으로 전송하게 한다. |
| **세션 (Session)** | 서버 | 서버 측에 상태를 저장하고, 클라이언트에게는 세션 ID만 쿠키로 전달한다. |
| **토큰 (JWT 등)** | 클라이언트 | 상태 정보를 암호화하여 클라이언트가 보관하고, 매 요청 시 서버에 전달한다. 서버는 상태를 저장하지 않고 토큰을 검증만 한다. |

> **핵심**: HTTP 자체는 여전히 Stateless이다. 위 기술들은 HTTP 위에서 **상태를 흉내 내는** 것이다.

### 세션 vs 토큰 비교

```
[세션 방식]
클라이언트 → 로그인 요청 → 서버 (세션 저장소에 상태 저장, 세션 ID 발급)
클라이언트 ← 세션 ID (쿠키로 전달) ← 서버
클라이언트 → 이후 요청 (쿠키에 세션 ID 포함) → 서버 (세션 저장소에서 상태 조회)

[토큰(JWT) 방식]
클라이언트 → 로그인 요청 → 서버 (토큰 생성, 서버에 상태 저장하지 않음)
클라이언트 ← JWT 토큰 ← 서버
클라이언트 → 이후 요청 (헤더에 토큰 포함) → 서버 (토큰 자체를 검증, 저장소 조회 불필요)
```

- **세션**: 서버에 상태를 저장하므로 서버 확장 시 세션 공유가 필요하다. (Redis 등 사용)
- **토큰(JWT)**: 서버가 상태를 저장하지 않으므로 Stateless 원칙에 더 가깝다. 서버 확장이 용이하다.

---

## 7. HTTP 버전의 변화

### HTTP/1.0
- 요청 하나당 TCP 연결을 새로 맺고, 응답 후 바로 끊었다.
- HTML 하나 받고 연결 끊고, 이미지 하나 받고 연결 끊고... → 매우 비효율적이었다.

### HTTP/1.1 (현재 가장 널리 사용)
- **Keep-Alive(지속 연결)**: 하나의 TCP 연결을 유지한 채 여러 요청/응답을 주고받을 수 있게 되었다.
- 연결을 매번 새로 맺는 오버헤드가 줄어들었다.
- 단, 요청은 **순서대로** 처리되어야 했다. (앞의 요청이 느리면 뒤의 요청도 대기 → HOL Blocking)

```
[HTTP/1.0]                         [HTTP/1.1]
연결 → 요청1 → 응답1 → 연결 끊기    연결 → 요청1 → 응답1
연결 → 요청2 → 응답2 → 연결 끊기           요청2 → 응답2
연결 → 요청3 → 응답3 → 연결 끊기           요청3 → 응답3 → 연결 끊기
```

### HTTP/2
- **멀티플렉싱(Multiplexing)**: 하나의 TCP 연결에서 여러 요청/응답을 **동시에** 병렬 처리한다. HOL Blocking 문제를 해결했다.
- 헤더 압축으로 전송 효율이 향상되었다.

### HTTP/3
- TCP 대신 **QUIC(UDP 기반)** 프로토콜을 사용한다.
- TCP의 연결 수립 지연(3-way handshake)을 제거하여 더 빠른 연결을 제공한다.

> **주의**: HTTP/1.1의 Keep-Alive는 TCP 연결을 재사용하는 것이지, 상태(Stateful)를 유지하는 것이 아니다. **HTTP는 모든 버전에서 Stateless**이다.

---

## 8. 전체 흐름 정리

```
[소켓 → HTTP → 스프링까지]

1. 운영체제가 소켓(TCP)을 제공한다.
2. HTTP는 TCP 소켓 위에서 동작하는 요청-응답 프로토콜이다.
3. 내장 Tomcat이 소켓을 열어 HTTP 요청을 수신한다.
4. 수신된 HTTP 요청을 서블릿(DispatcherServlet)에게 전달한다.
5. 스프링 MVC가 적절한 Controller를 찾아서 비즈니스 로직을 실행한다.
6. 실행 결과를 HTTP 응답으로 만들어서 소켓을 통해 클라이언트에게 전송한다.
```


---

## 9. 웹 서버 vs WAS (웹 애플리케이션 서버)

### 정적 콘텐츠 vs 동적 콘텐츠

| 종류 | 설명 | 예시 |
|------|------|------|
| **정적 콘텐츠** | 미리 만들어져 있는 파일. 누가 요청하든 항상 같은 내용이 반환된다. | HTML, CSS, JS, 이미지, 동영상 |
| **동적 콘텐츠** | 요청 시점에 **서버에서 프로그램이 실행**되어 내용이 생성된다. 사용자마다, 상황마다 다른 결과가 나올 수 있다. | JSP, 서블릿, API 응답(JSON) |

### 웹 서버 (Web Server) - Apache HTTP Server, Nginx

- **정적 콘텐츠를 제공**하는 서버이다.
- 클라이언트가 HTML, CSS, 이미지 등을 요청하면 파일 시스템에서 찾아서 그대로 응답한다.
- 자바 코드를 실행하는 기능이 없다. → JSP나 서블릿 같은 동적 콘텐츠를 직접 처리할 수 없다.

### WAS (Web Application Server) - Tomcat, Jetty, Undertow

- **동적 콘텐츠를 처리**할 수 있는 서버이다.
- 내부에 **서블릿 컨테이너**를 포함하고 있어서, 자바 코드(서블릿, JSP)를 실행할 수 있다.
- Tomcat은 대표적인 WAS(서블릿 컨테이너)이다.

### JSP는 왜 웹 서버만으로 처리할 수 없는가?

JSP(JavaServer Pages) 파일은 HTML 안에 자바 코드가 섞여 있는 파일이다.

```jsp
<!-- hello.jsp 예시 -->
<html>
  <body>
    <h1>안녕하세요, <%= request.getParameter("name") %>님!</h1>
    <p>현재 시간: <%= new java.util.Date() %></p>
  </body>
</html>
```

1. 클라이언트가 `GET /hello.jsp?name=홍길동` 이라는 **일반적인 HTTP 요청**을 보낸다. (클라이언트 입장에서는 평범한 HTTP 요청일 뿐이다)
2. 이 요청이 **Apache(웹 서버)** 에 도착하면, Apache는 자바 코드를 실행할 수 없다. JSP 파일을 그대로 보내면 브라우저에는 `<%= ... %>` 같은 자바 코드가 문자 그대로 노출될 뿐이다.
3. 그래서 Apache는 이 요청을 **Tomcat(WAS)** 에게 넘긴다.
4. Tomcat이 JSP 내부의 자바 코드를 **서버 측에서 실행**하여 순수한 HTML로 변환한다.
5. 변환된 HTML을 클라이언트에게 응답한다.

```
[클라이언트가 받는 최종 응답 - 순수 HTML]
<html>
  <body>
    <h1>안녕하세요, 홍길동님!</h1>
    <p>현재 시간: Wed Feb 11 14:30:00 KST 2026</p>
  </body>
</html>
```

> 정리하면, Tomcat은 "번역"이라기보다는 JSP 안의 **자바 코드를 실행(execute)** 하여 결과물인 HTML을 생성하는 역할이다.

### 과거 구조: Apache + Tomcat 연동

과거에는 Apache(웹 서버)와 Tomcat(WAS)을 분리해서 운영했다.

```
[과거 구조]
클라이언트 → Apache (웹 서버)
               ├─ 정적 파일 요청 (HTML, CSS, 이미지) → Apache가 직접 응답
               └─ 동적 요청 (JSP, 서블릿) → Tomcat에게 위임 → Tomcat이 처리 후 응답
```

**분리한 이유:**
- Apache가 정적 파일 처리에 더 효율적이고 빠르다.
- Tomcat은 자바 코드 실행에 집중한다.
- 앞단의 Apache가 리버스 프록시, SSL 처리, 로드 밸런싱 등을 담당한다.

### 현재 구조: Spring Boot의 내장 Tomcat

- Spring Boot는 Tomcat을 애플리케이션 내부에 내장시켰다.
- Tomcat 자체도 정적 파일을 서빙할 수 있으므로, 개발 단계에서는 Apache 없이 Tomcat만으로 충분하다.
- 실제 운영 환경에서는 앞단에 **Nginx**(Apache의 현대적 대안)를 두는 구조가 일반적이다.

```
[현대 운영 구조]
클라이언트 → Nginx (리버스 프록시, SSL, 정적 파일)
               └─ 동적 요청 → Spring Boot (내장 Tomcat) → 비즈니스 로직 처리 후 응답
```

### 웹 서버 vs WAS 비교

| | 웹 서버 (Apache, Nginx) | WAS (Tomcat, Jetty) |
|--|-------------------------|---------------------|
| 주요 역할 | 정적 콘텐츠 제공 | 동적 콘텐츠 처리 (자바 코드 실행) |
| 프로그램 실행 | 불가 | 가능 (서블릿, JSP) |
| 성능 특화 | 정적 파일 서빙, 동시 접속 처리 | 비즈니스 로직 실행 |
| 대표 제품 | Apache HTTP Server, Nginx | Tomcat, Jetty, Undertow |


클라이언트는 서버에 정적 파일 혹은 동적 파일을 요청할 수 있는데, url을 통해 정적인 파일을 요청하면 아파치와 같은 웹 서버가 이를 처리하고, jsp를 비롯한 동적인 파일을 uri를 통해 요청하면 톰켓을 비롯한 WAS가 이를 처리한다.
톰켓은 대표적인 자바 서블릿 컨테이너인데, 톰켓은 컨테이너 내부에 사용자 요청의 병렬처리를 위한 스레드 풀을 구현하고 요청을 처리하는 서블릿을 실행한다.

톰켓은 내부 컨테이너에 생성할 스레드의 수를 정의할 수 있는데, 사용자로부터 해당 스레드의 개수만큼 요청을 들어올 때까지는 스레드 객체를 계속해서 성성하다가, 그 이후의 요청은 해당 스레드 풀에서 응답을 마친 스레드에게 할당한다.

톰캣 서블릿 컨테이너 내부에서 프론트 컨트롤러와 리퀘스트 디스패쳐는 함께 작동하며, 프론트 컨트롤러는 사용자의 요청을 컨테이너 내부에 전달하고, 리퀘스트 디스패쳐는 다음 요청에 필요한 데이터 등을 페이지 사이를 오가며 쓸 수 있도록 해준다.

web.xml 파일을 거쳐서 서블릿 컨테이너로 전달된 요청은 서블릿 디스패쳐에 의해 적절한 서블릿으로 전달되는데, 이 때 전달할 클래스들이 메모리상에 떠야 하므로 이 부분을 스프링 ioc가 해준다. 이 과정은 어노테이션을 통해 이루어진다.