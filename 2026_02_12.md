빈: Ioc 관점에서, 스프링에서 생성하고 관리하는 객체
@Component: 스프링이 관리하는 객체임을 명시하는 어노테이션 -> 이렇게 선언된 클래스는 스프링 컨테이너가 메모리상에 띄운다.

AOP-Aspect Oriented Programming: 관점 지향 프로그래밍. 
프로그래밍에 대한 관심을 핵심 관점, 부가 관점으로 나누어 관심 기준으로 모듈화하는 프로그래밍 기법.

핵심 관점: 비즈니스 로직
부가 관점: 로깅, 보안, 트랜잭션 관리 등

PSA-Portable Service Abstraction: 이식 가능한 서비스 추상화
스프링에서 제공하는 기술들을 추상화하여 개발자가 쉽게 사용할 수 있도록 한 인터페이스.

예시:
- 스프링에서 데이터베이스에 접근할 때, 동일한 인터페이스를 유지하여 다양한 기술들을 사용할 수 있음. (JPA, MyBatis 등)
- WAS를 톰캣이 아닌 다른 WAS로 변경하더라도, 스프링의 인터페이스를 사용했다면 코드 변경을 최소화할 수 있음.

스프링부트 스타터는 의존성이 모여 있는 그룹.
spring-boot-starter-{작업유형}의 명명규칙이 있음.

종류:
1. spring-boot-starter-web: 웹 개발에 필요한 의존성들이 모여있는 그룹
2. spring-boot-starter-data-jpa: 데이터베이스 개발에 필요한 의존성들이 모여있는 그룹
3. spring-boot-starter-test: 테스트에 필요한 의존성들이 모여있는 그룹
등

스프링 프로젝트의 build.gradle 파일의 dependencies에서 스타터 목록 확인 가능.

각 스타터별 의존성은 IDE의 Gradle 탭 -> Dependencies에서 확인 가능.

스프링부트는 서버를 시작할 때 구성 파일을 읽어와서 설정함.
자동 파일은 spring.factories 파일에 담겨있는데, 이 파일은 META-INF 폴더에 위치함.
intelij에서 오른쪽 위 돋보기 클릭 -> files 클릭 -> spring-boot-autoconfigure/spring.factories 입력 후 첫번째 파일 선택으로 파일 내용 확인 가능.

스프링부트가 시작하면 spring.factories 파일에 설정된 클래스를 모두 불러온 뒤, 이후에 프로젝트에서 사용할 것들만 자동으로 구성.

왼쪽 프로젝트 구성에서 External Libraries 클릭 -> spring-boot-autoconfigure 선택 -> META-INF -> spring.factories 클릭으로 파일 내용 확인가능, 자동 설정 폴더들을 보면, 자동 구성되는 클래스는 AutoConfigureation, 속성 파일은 Properties를 통해 정의됨을 확인할 수 있음. -> 클래스에 대한 빈이 자동으로 생성됨. (없었다면 개발자가 일일이 설정해줘야 함.)

@SpringBootApplication 분석

1. @SpringBootConfiguration
2. @EnableAutoConfiguration
3. @ComponentScan

@SpringBootConfiguration: @Configuration과 동일한 역할을 수행. 스프링 설정 클래스임을 명시. -> 스프링 부트 관련 설정을 수행
@EnableAutoConfiguration: 스프링 부트의 자동 설정 기능을 활성화. spring.factories 파일에 정의된 AutoConfiguration 클래스들을 불러와서 자동으로 빈을 등록. -> spring.factories 파일에 정의된 AutoConfiguration 클래스들을 불러와서 자동으로 빈을 등록.
@ComponentScan: @Component, @Service, @Repository, @Controller 등의 어노테이션이 붙은 클래스들을 찾아서 자동으로 빈을 등록. (기본: @Component, 이후 용도에 따라 다름) -> 사용자가 등록한 빈을 읽고 등록

@ComponentScan이 스캔하는 어노테이션 종류
1. @Configuration: 설정 파일 등록
2. @Repository: ORM 매핑
3. @Controller, @RestController: 라우터
4. @Service: 비즈니스 로직
5. @Component: 일반 빈
각 어노테이션은 모두 @Component를 상속받는다. -> @Component가 붙은 클래스는 모두 빈으로 등록됨. 그러나 각 어노테이션은 @ComponentScan이 스캔할 때 용도에 따라 다르게 처리한다. (예: @Controller는 웹 계층으로, @Repository는 데이터베이스 계층으로 등)

@RestController: @Controller + @ResponseBody
@Controller: 컨트롤러 클래스임을 명시. 웹 계층의 빈으로 등록.
@ResponseBody: 메서드의 반환 값을 HTTP 응답 본문으로 변환하여 반환. (JSON, XML 등)

@RestController는 @Controller와 @ResponseBody를 합친 것으로, RESTful API를 개발할 때 사용한다.

라우터: HTTP 요청과 메서드를 연결하는 장치

스프링부트의 로직처리 과정
1. 클라이언트가 요청을 보내면 Controller가 요청을 받아 어떤 요청인지를 판단한다.
2. Controller는 요청을 분석하여 적절한 Service 클래스를 호출하고, Service는 그 요청에 맞는 작업을 실행한다. 
3. Service가 작업을 실행할 때, member 클래스로 객체를 구현하고, memberRepository를 통해 데이터베이스에 접근하여 작업을 수행한다.

스프링부트의 계층 구조
1. Controller: 웹 계층. HTTP 요청을 받아 비즈니스 계층으로 전송하는 역할을 한다.
2. Service: 비즈니스 계층. Service는 Controller와 Repository 사이에서 비즈니스 로직을 처리한다.
3. Repository: 데이터 계층. 데이터베이스에 접근하여 데이터를 처리한다. 이 과정에서 데이터베이스 계층과 상호작용하기 위한 객체인 DAO를 사용하기도 한다.
4. Database

스프링부트 프로젝트 디렉토리의 구조

main: 실제 코드를 작서하는 공간. 프로젝트 실행에 필요한 소스코드 및 리소스 파일이 모두 위치한다.
test: 테스트 코드 혹은 리소스 파일들이 위치한다.
build.gradle: 빌드를 설정하는 파일. 의존성이나 플러그인 설정 등 빌드에 필요한 설정을 담고 있다.
settings.gradle: 프로젝트를 설정하는 파일. 프로젝트의 이름이나 포함된 모듈 등을 설정한다.

resources/static: 정적 리소스들이 위치한다. (HTML, CSS, JavaScript, 이미지 등)
resources/templates: 템플릿 파일들이 위치한다. (Thymeleaf, JSP 등)
resources/application.yml: 스프링 부트의 설정을 담고 있는 파일. (데이터베이스 설정 정보, 로깅 설정 정보 등)

build.gradle 파일의 의존성 키워드

implementation: 컴파일, 런타임 모두에 필요.
testImplementation: 테스트 시의 컴파일, 런타임 모두에 필요. 메인 어플리케이션 코드에서는 사용하지 않음.
runtimeOnly: 런타임에만 필요.
compileOnly: 컴파일 시에만 필요.
